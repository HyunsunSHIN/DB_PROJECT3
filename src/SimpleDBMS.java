/* SimpleDBMS.java */
/* Generated By:JavaCC: Do not edit this line. SimpleDBMS.java */
import java.util.Set;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.stream.Stream;
import java.util.Arrays;
import java.util.Vector;
import java.util.StringTokenizer;
import java.io.File;
import java.io.UnsupportedEncodingException;


import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

public class SimpleDBMS implements SimpleDBMSConstants {
  static final String [] keywordList = new String []
  {
    "exit",
    "create",
    "table",
    "not",
    "null",
    "primary",
    "key",
    "foreign",
    "references",
    "int",
    "char",
    "date",
    "drop",
    "show",
    "tables",
    "desc",
    "select",
    "as",
    "from",
    "where",
    "and",
    "or",
    "is",
    "insert",
    "into",
    "values",
    "delete"
  };

  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));
  static myDatabase myDB = new myDatabase();
  static SimpleDBMS parser;
  static String tmpColDef = "";
  static String tmpPriKey = "";
  static String tmpForKey = "";
  static String tmpCols = "";
  static String tmpVals = "";
  static String delim = "|";
  static String createTblName = "";
  static String dropTblName = "";
  static Vector<String > tblNameList = new Vector<String >();
  static Hashtable<String,String> alias_table = new Hashtable<String,String>();
  static HashSet<HashMap<String,String>> unkown_tuple_space =new HashSet<HashMap<String,String>> ();
  static HashSet<HashMap<String,String>> tuple_space =new HashSet<HashMap<String,String>> ();
  static Hashtable <String, String> tblname_table = new Hashtable<String,String>(); //<K,V> = <colName, alias> OR <colName, @dupliacation>  static Hashtable <String, String> tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>  static Hashtable <String, String> selectedColumn_table = new Hashtable<String,String>(); // <K,V> = <alias, tblName.colName)  public static void main(String args []) throws ParseException
  {
    myDB.openDB();
    parser = new SimpleDBMS(System.in);
    tblNameList = myDB.getDB("@table name");
    handleSyntaxError(parser);
  }



  public static void handleSyntaxError(SimpleDBMS parser)
  {
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    { System.out.println("Syntax error");
      myDB.deleteTable(createTblName);
      parser = new SimpleDBMS(System.in);
      handleSyntaxError(parser);
    }
  }

  public static void handleDBError(SimpleDBMS parser)
  {
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

// Checking Functions// Get column definition from DB and check duplicate columns  final public 

boolean CheckInsertReferentialIntegrity(String tblName) throws ParseException {
String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);
      Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");

       for (int i = 0; i < forKeys.size(); i++)
       {
            boolean reached_references = false;
            String referenced_tblName = "";
            Vector<String> forkey_vertor = new Vector<String>();
            Vector<String> forkey_vector_referenced = new Vector<String>();
            String forKeyStr = forKeys.elementAt(i);
            StringTokenizer st = new StringTokenizer(forKeyStr, delim);
            while (st.hasMoreTokens())
            {
              String tmp = st.nextToken();
              if (tmp.contains("references"))
              { referenced_tblName = tmp.substring(12); // referenced table 을 참조해야하기 때문에, 이  이후에 작업하도록 한다.
                reached_references= true;
              }
              else if(!reached_references)
              { forkey_vertor.addElement(tmp);
              }
              else
              {
                forkey_vector_referenced.addElement(tmp);
              }
            }

           Vector<String> tuples_possibly_referenced= myDB.getDB(referenced_tblName+" @tuple"); // referencing table의 tuple들을 모두 조사한다
          /* 만약 attribute에 null이 들어오면, foreign key가 reference 하는 table이 없는 것으로 간주 ,true를 반환한다*/


              for(int j = 0 ; j < forkey_vertor.size() ; j++){
                  String forkey_value_referencing
                  = GetColumnValue(tupleString_input,forkey_vertor.elementAt(j)); // null로 참조하는 경우, true.
                  if(forkey_value_referencing.equals("null")){ {if ("" != null) return true;} }
               }


           if(tuples_possibly_referenced.size() == 0 ){
           {if ("" != null) return false;}
           }

           boolean found = true ;
           for(int n = 0; n < tuples_possibly_referenced.size() ; n++){
                String tupleString_to_Compare = tuples_possibly_referenced.elementAt(n);

                found = true;

                for(int j = 0 ; j < forkey_vertor.size() ; j++){
                             String forkey_value_referencing
                              = GetColumnValue(tupleString_input,forkey_vertor.elementAt(j));

                             String forkey_value_refered
                              = GetColumnValue(tupleString_to_Compare, forkey_vector_referenced.elementAt(j));
                              if(!forkey_value_refered.equals(forkey_value_referencing) && (forkey_value_referencing!= "null") ){
                              found = false; break;
                              }
                }
                if( found ){ break; } // 여기에 도달했다는 것은,
                 // 특정 forein Key column들이 모두 같은 tuple을 발견했다는 것이다. 그러므로 다른 tuple들을 조사할 필요가 없으므로
                 // break를 시켜준다 또한 found 가 ture일 때에만
                 // 이게 발견 되어야만 다음 foreign key 를 조사할 수 있도록한다 바로 아래 코드가 그런 역할을 한다
        }
           if(!found ){ {if ("" != null) return false;} }
       }
       {if ("" != null) return true;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertDuplicatePrimaryKeyError(String tblName) throws ParseException {
String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);
         String PriKeys ="";
         Vector<String> PriKeysVector = myDB.getDB(tblName + " @primary key");

        if( PriKeysVector.size() == 0 ){{if ("" != null) return false;}}
        else{ PriKeys = PriKeysVector.elementAt(0);}

        Vector<String> tuples = myDB.getDB(tblName+ " @tuple");

         if(tuples.size() == 0 ){ {if ("" != null) return false;}}
         for(int i = 0 ; i < tuples.size() ; i ++ ){

             StringTokenizer st = new StringTokenizer(PriKeys, delim);
             String tupleString = tuples.elementAt(i);

             boolean duplication_occur = true;

             while(st.hasMoreTokens()){
                String PriKey = st.nextToken();
                String Value = GetColumnValue(tupleString,PriKey);
                String Value_input = GetColumnValue(tupleString_input,PriKey);

                if(!Value.equals(Value_input)){ duplication_occur= false; break;  }
             }
             if( duplication_occur){ {if ("" != null) return true;} }
         }
     {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnNonNullable(String tblName) throws ParseException {
addNullExiplicitly(tblName);
        String tupleToCheck = myDB.getDB(tblName + " @tmptuple").elementAt(0);
        StringTokenizer st = new StringTokenizer(tupleToCheck, delim);

            while (st.hasMoreTokens())
            {
              String col_name = st.nextToken();
              String col_val = st.nextToken();
              if(col_val.equals("null") &&
               !IsColumnNullable(tblName, col_name)){
                 {if ("" != null) return col_name;}
              }
            }
        {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnExistence(String tblName) throws ParseException {
// tmpCols =>분리 & tblNAm @colDef의 Value가 포함하고있나?
        Vector<String> colNames = new Vector<String>();
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        StringTokenizer st = new StringTokenizer(colDef, delim);
        String replacer_tmpCols = "";

          while (st.hasMoreTokens())
            {
              String colName = st.nextToken();
              String colType = st.nextToken();
              colNames.addElement(colName);
              replacer_tmpCols = replacer_tmpCols.concat("|"+colName);
            }

        if(tmpCols.length() > 0 ){
             StringTokenizer st2 = new StringTokenizer(tmpCols.substring(1), delim);
                  while (st2.hasMoreTokens())
                  {
                    String colName = st2.nextToken();
                    if (!colNames.contains(colName))
                    {
                      {if ("" != null) return colName;}
                    }
                  }
        } else {  tmpCols = replacer_tmpCols; }
        {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertTypeMismatch(String tblName) throws ParseException {
StringTokenizer st1 = new StringTokenizer(tmpCols.substring(1), delim);
      StringTokenizer st2 = new StringTokenizer(tmpVals.substring(1), delim);
      String tupleInput = "";
      if(st1.countTokens() != st2.countTokens() ){
        {if ("" != null) return true;}
      }

                while (st1.hasMoreTokens())
                  {
                    String colName = st1.nextToken();
                    String colVal = st2.nextToken();
                    String colType = GetColumnType(tblName, colName);
                      if(colVal.equals("null")){
                      tupleInput += "|"+colName+"|"+colVal;
                      continue; }
                      if(colType.equals("int")){
                           try {
                                Integer.parseInt(colVal); }
                           catch (NumberFormatException e )
                           {
                                {if ("" != null) return true;}
                           }


                      } else if (colType.equals("date")){

                            String[] yyyymmdd_arr = colVal.split("-");
                            if( yyyymmdd_arr.length != 3 ){ {if ("" != null) return true;} }
                                for(int k = 0 ; k < 3 ; k ++ ){
                                    try {
                                            Integer.parseInt(yyyymmdd_arr[k]); }
                                            catch (NumberFormatException e ){
                                            {if ("" != null) return true;}
                                    }
                                }

                      } else if (colType.startsWith("char(")){
                        if (!colVal.startsWith("'") || !colVal.endsWith("'")){
                              {if ("" != null) return true;}
                          } else {
                            String lengthOfChar = colType.substring(5,colType.length()-1);
                                                         int lengthOfChar_int = Integer.parseInt(lengthOfChar);
                                                         if(colVal.length() > lengthOfChar_int+ 2)
                                                         { colVal = colVal.substring(0, Integer.parseInt(lengthOfChar)+1) + "'"; }
                          }
                      } else {
                        {if ("" != null) return true;}
                      }

                 tupleInput += "|"+colName+"|"+colVal;
                }

          myDB.putDB(tblName + " @tmptuple", tupleInput.substring(1));
     {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckDuplicateColumnDef(String tblName) throws ParseException {
Vector<String> tmp = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      if (tmp.contains(colName))
      {
        {if ("" != null) return true;}
      }
      else
      {
        tmp.addElement(colName);
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names from DB and check whether input table name exists in DB  final public boolean CheckTableExistence(String tblName) throws ParseException {
Vector<String> tables = myDB.getDB("@table name");
    {if ("" != null) return tables.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get primary key definition from this table and check whether it occurs more than one times  final public boolean CheckDuplicatePrimaryKeyDef(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    {if ("" != null) return priKeys.size() > 1;}
    throw new Error("Missing return statement in function");
  }

// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DB  final public String CheckNonExistingColumnDef(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> colNames = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      colNames.addElement(colName);
    }
    // Check primary key definition
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st2 = new StringTokenizer(priKeyStr, delim);
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        if (!colNames.contains(colName))
        {
          {if ("" != null) return colName;}
        }
      }
    }
    // Check foreign key definition
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st3 = new StringTokenizer(forKeyStr, delim);
      while (st3.hasMoreTokens())
      {
        String colName = st3.nextToken();
        if (colName.contains("references"))  // references 라는게 있으면, syntax 에러를 뱉어내기 위함인가?
        {
          break;
        }
        else if (!colNames.contains(colName))
        {
          {if ("" != null) return colName;}
        }
      }
    }
    {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names from this table and check whether those referenced tables are really exist  final public boolean CheckReferenceTableExistence(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> tblNames = myDB.getDB("@table name");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        refTblName = st.nextToken();
        if (refTblName.contains("references"))  // WHY THIS?
        {
          refTblName = refTblName.substring(12);
          break;
        }
      }
      if (!tblNames.contains(refTblName))
      {
        {if ("" != null) return true;}
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are not primary key of referenced table  final public boolean CheckReferenceNonPrimaryKey(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      Vector<String> refPriKeyCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      Vector<String> refPriKeys = myDB.getDB(refTblName + " @primary key");
      if (refPriKeys.size() > 0)
      {
        // Get primary key of referenced table
        String refPriKeyStr = refPriKeys.elementAt(0);
        StringTokenizer st2 = new StringTokenizer(refPriKeyStr, delim);
        while (st2.hasMoreTokens())
        {
          String refPriKeyColName = st2.nextToken();
          refPriKeyCols.addElement(refPriKeyColName);
        }
      }
      // Check whether all of referenced columns are primary key
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refPriKeyCols.contains(refCols.elementAt(j)))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are really exist in referenced table  final public boolean CheckReferenceColumnExistence(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      String refRealColDefStr = myDB.getDB(refTblName + " @column definition").elementAt(0);
      Vector<String> refRealColNames = new Vector<String>();
      StringTokenizer st2 = new StringTokenizer(refRealColDefStr, delim);
      // Get columns of referenced table
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        refRealColNames.addElement(colName);
      }
      // Check whether all of referenced columns exist in referenced table
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refRealColNames.contains(refCols.elementAt(j)))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get type of referenced columns and referencing columns and check whether types of both columns are same  final public boolean CheckReferenceType(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns and referencing columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> forCols = new Vector<String>();
      Vector<String> refCols = new Vector<String>();
      String refTblName = "";
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
        else
        {
          String forColName = tmpstr;
          forCols.addElement(forColName);
        }
      }
      // If number of referenced columns and referencing columns are different, type error
      if (refCols.size() != forCols.size())
      {
        {if ("" != null) return true;}
      }
      // Check type of these columns one by one
      else
      {
        for (int j = 0; j < refCols.size(); j++)
        {
          String forColType = GetColumnType(tblName, forCols.elementAt(j));
          String refColType = GetColumnType(refTblName, refCols.elementAt(j));
          if (!forColType.equals(refColType))
          {
            {if ("" != null) return true;}
          }
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names of DB and check whether this table exists  final public boolean CheckNoSuchTable(String tblName) throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    {if ("" != null) return !tblNames.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckTupleIsReferenced(String refTblName, String tuple) throws ParseException {boolean thisTupleIsReferenced = false ;
Vector<String> tblNames = myDB.getDB("@table name");
         for (int i = 0; i < tblNames.size(); i++)
         {
           Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");
           for (int j = 0; j < forKeys.size(); j++)
           { Vector<String> KeysToCompare  = new Vector<String>();
             String forKeyStr = forKeys.elementAt(j);
             StringTokenizer st = new StringTokenizer(forKeyStr, delim);
             String tmpTbl = "";
             while (st.hasMoreTokens())
             {
               String tmp = st.nextToken();
               if (tmp.contains("references"))
               {
                 tmpTbl = tmp.substring(12);
                 break;
               } else { KeysToCompare.add(tmp); }
             }
             if (tmpTbl.equals(refTblName))
             { Vector<String> tuples_possibly_referencing = myDB.getDB(tblNames.elementAt(i)+ " @tuple");

               for( String suspect_tuple_referencing : tuples_possibly_referencing){
                  thisTupleIsReferenced = true;

                  for(int k = 0 ; k < KeysToCompare.size() ; k++)
                  {
                     String value = GetColumnValue(suspect_tuple_referencing, KeysToCompare.elementAt(k));
                     String value_input = GetColumnValue(tuple, KeysToCompare.elementAt(k));
                     if(!value.equals(value_input)){ thisTupleIsReferenced= false; break; }
                  }

                  if( thisTupleIsReferenced){ {if ("" != null) return true;} }
               }

             }
           }
         }
         {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names of DB and check whether this table is referenced by other table  final public boolean CheckDropReferencedTable(String refTblName) throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    for (int i = 0; i < tblNames.size(); i++)
    {
      Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");
      for (int j = 0; j < forKeys.size(); j++)
      {
        String forKeyStr = forKeys.elementAt(j);
        StringTokenizer st = new StringTokenizer(forKeyStr, delim);
        String tmpTbl = "";
        while (st.hasMoreTokens())
        {
          String tmp = st.nextToken();
          if (tmp.contains("references"))
          {
            tmpTbl = tmp.substring(12);
            break;
          }
        }
        if (tmpTbl.equals(refTblName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether there is no table  final public boolean CheckShowTablesNoTable() throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    {if ("" != null) return (tblNames.size() == 0);}
    throw new Error("Missing return statement in function");
  }

// Error Functions  final public 

void SelectColumnResolveError(String colName) throws ParseException {
System.out.println("Selection has failed: fail to resolve '"+colName+"'");
    handleDBError(parser);
  }

  final public void SelectTableExistenceError(String tblName) throws ParseException {
System.out.println("Selection has failed: '"+tblName+"' does not exist");
    handleDBError(parser);
  }

  final public void WhereIncomparableError() throws ParseException {
System.out.println("Where clause try to compare incomparable values");
    handleDBError(parser);
  }

  final public void WhereTableNotSpecifiedError() throws ParseException {
System.out.println("Where clause try to reference tables which are not specified");
    handleDBError(parser);
  }

  final public void WhereColumnNotExistError() throws ParseException {
System.out.println("Where clause try to reference non existing column");
    handleDBError(parser);
  }

  final public void WhereAmbiguousReferenceError() throws ParseException {
System.out.println("Where clause contains ambiguous reference");
    handleDBError(parser);
  }

  final public void NotUniqueAliasrError(String alias) throws ParseException {
System.out.println("Not unique table/alias: '"+alias+"'");
    handleDBError(parser);
  }

  final public void InsertReferentialIntegrityError() throws ParseException {
System.out.println("Insertion has failed: Referential integrity violation");
    handleDBError(parser);
  }

  final public void InsertDuplicatePrimaryKeyError() throws ParseException {
System.out.println("Insertion has failed: Primary key duplication");
        handleDBError(parser);
  }

  final public void InsertColumnNonNullableError(String colName) throws ParseException {
System.out.println("Insertion has failed: '"+colName+"' is not nullable");
    handleDBError(parser);
  }

  final public void InsertTypeMismatchError() throws ParseException {
System.out.println("Insertion has failed:Insertion has failed: Types are not matched");
    handleDBError(parser);
  }

  final public void InsertColumnExistenceError(String colName) throws ParseException {
System.out.println( "Insertion has failed: '"+colName+"' does not exist");
    handleDBError(parser);
  }

  final public void DuplicateColumnDefError(String tblName) throws ParseException {
System.out.println("Create table has failed: column definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void TableExistenceError() throws ParseException {
System.out.println("Create table has failed: table with the same name already exist");
    handleDBError(parser);
  }

  final public void CharLengthError() throws ParseException {
System.out.println("Char length should be > 0");
    handleDBError(parser);
  }

  final public void DuplicatePrimaryKeyDefError(String tblName) throws ParseException {
System.out.println("Create table has failed: primary key definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NonExistingColumnDefError(String tblName, String colName) throws ParseException {
System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTableExistenceError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non existing table");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceNonPrimaryKeyError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non primary key column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceColumnExistenceError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non existing column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTypeError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references wrong type");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NoSuchTable() throws ParseException {
System.out.println("No such table");
    handleDBError(parser);
  }

  final public void DropReferencedTableError(String tblName) throws ParseException {
System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");
    handleDBError(parser);
  }

  final public void ShowTablesNoTable() throws ParseException {
System.out.println("There is no table");
    handleDBError(parser);
  }

// utility functions  final public 

int DeleteTuples(String tblName , HashSet<HashMap<String,String>> result) throws ParseException {int fail_count = 0;
   int count = 0 ;
String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);

     Vector <String> colDefVector_with_tblName = new Vector<String>();
     Vector <String> colDefVector = new Vector<String>();
     Vector<String> tuples = myDB.getDB(tblName+ " @tuple");

     StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);
      // Get columns of referenced table
     while (st2.hasMoreTokens())
          {
            String colName = st2.nextToken();
            String colType = st2.nextToken();
            colDefVector_with_tblName.addElement(tblName+"."+colName);
            colDefVector.addElement(colName);
          }

    for(HashMap<String,String> result_tuple : result ){

        for( int i = 0 ; i < tuples.size() ; i++ ){

            boolean deleteThis = true;
            for( int j = 0 ; j < colDefVector.size() ; j ++ ){
                 String value = GetColumnValue(tuples.elementAt(i), colDefVector.elementAt(j));
                 String value_result = result_tuple.get(colDefVector_with_tblName.elementAt(j));
                if(!value.equals(value_result)){
                    deleteThis = false;
                }
            }

            if(deleteThis){

            // CHECK WHETHER THIS IS allowedto be delted with the referencing constraints.
            if ( CheckTupleIsReferenced(tblName, tuples.elementAt(i)) )
            { fail_count++; }
            else
            {   count++; myDB.deleteTupleDB(tblName+ " @tuple",tuples.elementAt(i));
            }
          }
        }

        if(fail_count > 0){
         System.out.println( fail_count+ " row(s) are not deleted due to referential integrity");
        }
    }
    {if ("" != null) return count;}
    throw new Error("Missing return statement in function");
  }

  final public void CheckAndModifyAliasVector(Vector<String> alias_vector) throws ParseException {String colName = "" ; String[] columnInfo; String tblName;
if(alias_vector.size() == 0){ // then select * must be called.
        alias_vector.addAll(tblcol_table.keySet());
          for( int i = 0 ; i < alias_vector.size() ; i ++ )
          { String alias = alias_vector.elementAt(i);
            selectedColumn_table.put(alias,alias);
           }
      }

       for( int i = 0 ; i < alias_vector.size() ; i ++ ){

        String colName_str = selectedColumn_table.get(alias_vector.elementAt(i));
        columnInfo = colName_str.split("\u005c\u005c.");
        if(columnInfo.length == 2){ // tblName.colName과 col Name을 구분한다.
           tblName = columnInfo[0];
           colName  = columnInfo[1];

           if( CheckNoSuchTable(tblName) // tblName이 from 절에 나오는 alias인 경우에도, 올바른 경우이므로 이 경우에 에러를 던지지 않기 위해서 이 부분이 필요
            && !alias_table.containsKey(tblName)){SelectTableExistenceError(tblName); }

           Set<String> keySet = tblcol_table.keySet(); // tuple의 key 값 중에 하나인가?
           if(!keySet.contains(colName_str)){ SelectColumnResolveError(colName);}

        } else {
           String operand = colName_str;
           if(!tblname_table.containsKey(operand)){ SelectColumnResolveError(colName_str);}
           else if (tblname_table.get(operand).equals("@duplication"))
           { SelectColumnResolveError(colName_str); }
             selectedColumn_table.put(alias_vector.elementAt(i),  tblname_table.get(operand)+"."+operand);
        }
      }
  }

  final public HashSet<HashMap<String,String>> FilterTuples(String operand1, String operand2, String operator) throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
 String value1 ="" ; String dataType1 ="";
 String value2 ="" ; String dataType2 ="";
 Integer value1_int = 0 ;
 Integer value2_int = 0;
 boolean value1IsAttribute= true;
 boolean value2IsAttribute= true ;
 int comparation = 0 ;
Set<String> keySet = tblcol_table.keySet();
      if(!keySet.contains(operand1))
      { value1IsAttribute = false;
        value1 = operand1.substring(1);
        dataType1 = operand1.substring(0,1);
      } else { dataType1 = tblcol_table.get(operand1).substring(0,1);}

      if(!keySet.contains(operand2))
      { value2IsAttribute = false;
        value2 = operand2.substring(1);
        dataType2 = operand2.substring(0,1);
      } else { dataType2 = tblcol_table.get(operand2).substring(0,1);}


     if(!dataType1.equals(dataType2)){ WhereIncomparableError(); }
     else {
        for(HashMap<String,String> tuple : tuple_space){
            if(value1IsAttribute){ value1 = tuple.get(operand1); }
            if(value2IsAttribute){ value2 = tuple.get(operand2); }

               if( dataType1.equals("i") && !value1.equals("null") && !value2.equals("null")){
                value1_int = Integer.parseInt(value1);
                value2_int = Integer.parseInt(value2);
                comparation = value1_int.compareTo(value2_int);
               } else { comparation = value1.compareTo(value2); }


            // if( ( value1.equals("null") && value2.equals("null")) ){ } else
            if( ( value1.equals("null") || value2.equals("null")) )
            { unkown_tuple_space.add(tuple); }

            switch(operator){
               case "<" : { if(comparation<0) result.add(tuple); break; }
               case ">" : { if(comparation>0) result.add(tuple); break; }
               case "=" :{ if(comparation == 0 )  result.add(tuple); break; }
               case ">=" :{ if(comparation>=0) result.add(tuple); break; }
               case "<=" :{ if(comparation <= 0 ) result.add(tuple); break; }
               case "!=" :{ if(comparation!= 0) result.add(tuple); break; }
            }
         }
       }
     {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void ExtendTableHash(String alias) throws ParseException {
String tblName = alias_table.get(alias);
          String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
          StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);
          Vector <String> colDefVector = new Vector<String>();

          while (st2.hasMoreTokens())
                      {
                        String colName = st2.nextToken();
                        String colType = st2.nextToken();
                        tblcol_table.put(alias+"."+colName, colType);
                        if(tblname_table.containsKey(colName)){
                                 tblname_table.put(colName,"@duplication");
                        } else { tblname_table.put(colName,alias); }
                      }
  }

  final public void ExtendTupleSpace(String alias) throws ParseException {
if(tuple_space.size() == 0 ){

      String tblName = alias_table.get(alias);
      String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
      Vector <String> colDefVector_alias = new Vector<String>();
      StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);
      Vector <String> colDefVector = new Vector<String>();

            while (st2.hasMoreTokens())
            {
              String colName = st2.nextToken();
              String colType = st2.nextToken();
              colDefVector_alias.addElement(alias+"."+colName);
              colDefVector.addElement(colName);
            }

      Vector<String> tuples = myDB.getDB(tblName+ " @tuple");

       for(int i = 0 ; i < tuples.size() ; i++){
            HashMap<String,String> tuple = new HashMap<String,String>();

             for(int j = 0 ; j <colDefVector.size() ; j++ ){
                String colName =  colDefVector.elementAt(j);
                String value = GetColumnValue(tuples.elementAt(i), colName);
                tuple.put(colDefVector_alias.elementAt(j), value);
             }
           tuple_space.add(tuple);
       }
    }
    else {
            HashSet<HashMap<String,String>> newTupleSet =new HashSet<HashMap<String,String>> ();

            for(HashMap<String,String> tuple : tuple_space){

                      String tblName = alias_table.get(alias);
                      String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
                      Vector <String> colDefVector_alias = new Vector<String>();
                      Vector <String> colDefVector = new Vector<String>();

                      StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);
                            // Get columns of referenced table
                            while (st2.hasMoreTokens())
                            {
                              String colName = st2.nextToken();
                              String colType = st2.nextToken();
                              colDefVector_alias.addElement(alias+"."+colName);
                              colDefVector.addElement(colName);
                            }

                      Vector<String> tuples = myDB.getDB(tblName+ " @tuple");

                       for(int i = 0 ; i < tuples.size() ; i++){
                             HashMap<String,String> tuple_extended = (HashMap<String,String> ) tuple.clone();

                             for(int j = 0 ; j <colDefVector.size() ; j++ ){
                                String colName =  colDefVector.elementAt(j);
                                String value = GetColumnValue(tuples.elementAt(i), colName);
                                tuple_extended.put(colDefVector_alias.elementAt(j), value);
                             }
                                  newTupleSet.add(tuple_extended);
                       }
            }

            tuple_space = newTupleSet;
    }
  }

  final public String GetColumnValue(String tupleString, String colName) throws ParseException {
StringTokenizer st =  new StringTokenizer(tupleString, delim);
         while (st.hasMoreTokens())
                    {
                      String col_name = st.nextToken();
                      String col_val = st.nextToken();
                      if(col_name.equals(colName)){
                        {if ("" != null) return col_val;}
                      }
                    }
      {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void addNullExiplicitly(String tblName) throws ParseException {
String colValStr = myDB.getDB(tblName + " @tmptuple").elementAt(0);

            StringTokenizer st1 = new StringTokenizer(colValStr, delim);
            Vector<String> tmp = new Vector<String>();

              while (st1.hasMoreTokens())
                        {
                          String col_name = st1.nextToken();
                          String col_value = st1.nextToken();
                          tmp.addElement(col_name);
                        }

            String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
            StringTokenizer st = new StringTokenizer(colDef, delim);
            while (st.hasMoreTokens())
            {
              String colName = st.nextToken();
              String colType = st.nextToken();
              if (!tmp.contains(colName))
              {
                 colValStr += "|"+colName+"|null";
              }
            }

            myDB.deleteDB(tblName + " @tmptuple");
            myDB.putDB(tblName+" @tmptuple", colValStr);
  }

  final public boolean IsColumnNullable(String tblName, String colName) throws ParseException {
String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        st2.nextToken();
        {if ("" != null) return !st2.hasMoreTokens();}
      }
    }
    {if ("" != null) return false;} // never reached since the argument must be valid.

    throw new Error("Missing return statement in function");
  }

// Get type of column  final public String GetColumnType(String tblName, String colName) throws ParseException {
String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        {if ("" != null) return st2.nextToken();}
      }
    }
    {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

// Change columns of primary key to not null  final public void ChangeToNotNull(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      // Get primary keys
      Vector<String> priCols = new Vector<String>();
      String priKeyStr = priKeys.elementAt(0);
      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
      myDB.deleteDB(tblName + " @column definition");
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        priCols.addElement(st.nextToken());
      }
      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);
      String newColDef = "";
      // Change type of primary keys to not null by deleting and re-inserting primary key data
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        StringTokenizer st3 = new StringTokenizer(colType, "*");
        String realColType = st3.nextToken();
        if (priCols.contains(colName) && !st3.hasMoreTokens())
        {
          newColDef += "|" + colName + "|" + realColType + "*not null";
        }
        else
        {
          newColDef += "|" + colName + "|" + colType;
        }
      }
      myDB.putDB(tblName + " @column definition", newColDef.substring(1));
    }
  }

// Perform drop table query  final public void DropTable(String tblName) throws ParseException {
myDB.deleteTable(tblName);
    myDB.deleteDB("@table name");
    tblNameList.remove(tblName);
    for (int i = 0; i < tblNameList.size(); i++)
    {
      myDB.putDB("@table name", tblNameList.elementAt(i));
    }
  }

  final public void ShowTuples(Vector<String>alias_vector,  HashSet<HashMap<String,String>> result) throws ParseException {String line = "";
 String lineformat = "";
 String format = "";
 String field_name_format = "";
for(int j = 0 ; j <  26 ; j ++){
            line += "-";
        } // generate lines.
        for( int i = 0 ; i < alias_vector.size() ; i++ ){
                    lineformat += "%-26s+"  ;
        } // generate line format
        String[] lines = new String[alias_vector.size()]; // generate lines array.
        for( int i = 0 ; i < alias_vector.size() ; i++ ){

             field_name_format += "  %-22s  |"  ;

        } // generate field_name format
        for( int i = 0 ; i < alias_vector.size() ; i++ ){
                    if((i % 2) == 0)
                    { format += "  %22s  |"  ; }
                    else
                    {format += "  %-22s  |"  ;}
                    lines[i] = line;
        } // generate field format
        String[] selectedColumnString = new String[alias_vector.size()];
        selectedColumnString = alias_vector.toArray(selectedColumnString);
        System.out.println(String.format(lineformat, (Object[])lines));
        System.out.println(String.format(field_name_format, (Object[])selectedColumnString));
        System.out.println(String.format(lineformat, (Object[])lines));


        /* completion of Fomatting. now start showing datas from tuples */


         for(HashMap<String,String> item : result){

                Vector<String> tupleVector = new Vector<String>(alias_vector.size());

                for(int k = 0 ; k < alias_vector.size() ; k ++ ){
                    String realAttributeName = selectedColumn_table.get(alias_vector.elementAt(k));
                    String value = item.get(realAttributeName);
                    tupleVector.add(k,value);
                }

               String[] tupleResult = new String[tupleVector.size()];
               tupleResult = tupleVector.toArray(tupleResult);
               System.out.println(String.format(format, (Object[])tupleResult));
               System.out.println(String.format(lineformat, (Object[])lines));
         }
  }

// Perform show tables query  final public void ShowTables() throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    System.out.println("-------------------------");
    for (int i = 0; i < tblNames.size(); i++)
    {
      System.out.println(tblNames.elementAt(i));
    }
    System.out.println("-------------------------");
  }

// Check whether given column is primary key column  final public boolean IsPrimaryKey(String tblName, String colName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.equals(colName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether given column is foreign key column  final public boolean IsForeignKey(String tblName, String colName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.contains("references"))
        {
          break;
        }
        else if (tmp.equals(colName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Perform desc query  final public void Describe(String tblName) throws ParseException {
String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    System.out.println("------------------------------------------------------------");
    System.out.println("table_name [" + tblName + "]");
    System.out.printf("%-25s%-15s%-10s%-10s\u005cn", "column_name", "type", "null", "key");
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      boolean isNotNull = false;
      boolean isPriKey = IsPrimaryKey(tblName, colName);
      boolean isForKey = IsForeignKey(tblName, colName);
      StringTokenizer st2 = new StringTokenizer(colType, "*");
      String realColType = st2.nextToken();
      if (st2.hasMoreTokens())
      {
        isNotNull = true;
      }
      System.out.printf("%-25s%-15s", colName, realColType);
      if (isNotNull)
      {
        System.out.printf("%-10s", "N");
      }
      else
      {
        System.out.printf("%-10s", "Y");
      }
      if (isPriKey && isForKey)
      {
        System.out.printf("%-10s\u005cn", "PRI/FOR");
      }
      else if (isPriKey)
      {
        System.out.printf("%-10s\u005cn", "PRI");
      }
      else if (isForKey)
      {
        System.out.printf("%-10s\u005cn", "FOR");
      }
      else
      {
        System.out.print("\u005cn");
      }
    }
    System.out.println("------------------------------------------------------------");
  }

// Success Functions  final public void CreateTableSuccess() throws ParseException {
System.out.println("'" + createTblName + "' table is created");
  }

  final public void DropSuccess() throws ParseException {
System.out.println("'" + dropTblName + "' table is dropped");
  }

// Parsing Functions  final public void Command() throws ParseException {
    QueryList();
  }

  final public void QueryList() throws ParseException {int i;
    label_1:
    while (true) {
      i = Query();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:{
        jj_consume_token(SEMICOLON);
Success(i);
        break;
        }
      case 1:
      case 2:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 1:{
          jj_consume_token(1);
          break;
          }
        case 2:{
          jj_consume_token(2);
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
Success(i);
          System.out.print("DB_2014-16962 > ");
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
  }

  final public int Query() throws ParseException {int i;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CREATE_TABLE:{
      i = CreateTableQuery();
      break;
      }
    case DROP_TABLE:{
      i = DropTableQuery();
      break;
      }
    case SHOW_TABLES:{
      i = ShowTablesQuery();
      break;
      }
    case DESC:{
      i = DescQuery();
      break;
      }
    case SELECT:{
      i = SelectQuery();
      break;
      }
    case INSERT_INTO:{
      i = InsertQuery();
      break;
      }
    case DELETE_FROM:{
      i = DeleteQuery();
      break;
      }
    case EXIT:{
      i = ExitQuery();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return i;}
    throw new Error("Missing return statement in function");
  }

  final public int ExitQuery() throws ParseException {
    jj_consume_token(EXIT);
{if ("" != null) return - 1;}
    throw new Error("Missing return statement in function");
  }

  final public int CreateTableQuery() throws ParseException {String tblName;
  String colName;
    jj_consume_token(CREATE_TABLE);
    tblName = TableName();
if (CheckTableExistence(tblName))
    {
      TableExistenceError();
    }
    TableElementList(tblName);
myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));
    tmpColDef = "";
    tmpPriKey = "";
    tmpForKey = "";
    if (CheckDuplicateColumnDef(tblName))
    {
      DuplicateColumnDefError(tblName);
    }
    else if (CheckDuplicatePrimaryKeyDef(tblName))
    {
      DuplicatePrimaryKeyDefError(tblName);
    }
    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)
    {
      NonExistingColumnDefError(tblName, colName);
    }
    else if (CheckReferenceTableExistence(tblName))
    {
      ReferenceTableExistenceError(tblName);
    }
    else if (CheckReferenceColumnExistence(tblName))
    {
      ReferenceColumnExistenceError(tblName);
    }
    else if (CheckReferenceNonPrimaryKey(tblName))
    {
      ReferenceNonPrimaryKeyError(tblName);
    }
    else if (CheckReferenceType(tblName))
    {
      ReferenceTypeError(tblName);
    }

    ChangeToNotNull(tblName);
    createTblName = tblName;
    myDB.putDB("@table name", tblName);
    tblNameList.addElement(tblName);
    {if ("" != null) return 0;}
    throw new Error("Missing return statement in function");
  }

  final public void TableElementList(String tblName) throws ParseException {
    jj_consume_token(LEFT_PAREN);
    TableElement(tblName);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      TableElement(tblName);
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ALPHABET:
    case LEGAL_IDENTIFIER:{
      ColumnDefinition();
      break;
      }
    case PRIMARY_KEY:
    case FOREIGN_KEY:{
      TableConstraintDefinition(tblName);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException {String colName = "";
  String dataType = "";
  String notNull = "";
    if (jj_2_1(2147483647)) {
      colName = ColumnName();
      dataType = DataType();
      jj_consume_token(NOT_NULL);
notNull = "*not null";
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        colName = ColumnName();
        dataType = DataType();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
tmpColDef += delim + colName + delim + dataType + notNull;
  }

  final public void TableConstraintDefinition(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIMARY_KEY:{
      PrimaryKeyConstraint(tblName);
      break;
      }
    case FOREIGN_KEY:{
      ReferentialKeyConstraint(tblName);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint(String tblName) throws ParseException {
    jj_consume_token(PRIMARY_KEY);
    ColumnNameList(true);
myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));
  }

  final public void ReferentialKeyConstraint(String tblName) throws ParseException {String referedTblName;
    jj_consume_token(FOREIGN_KEY);
    ColumnNameList(false);
    jj_consume_token(REFERENCES);
    referedTblName = TableName();
tmpForKey += delim + "@references&" + referedTblName;
    ColumnNameList(false);
myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));
    tmpForKey = "";
  }

  final public void ColumnNameList_insertion() throws ParseException {String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
{
      tmpCols += delim + colName;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
{
        tmpCols += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void ColumnNameList(boolean isPrimaryKey) throws ParseException {String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
if (isPrimaryKey)
    {
      tmpPriKey += delim + colName;
    }
    else
    {
      tmpForKey += delim + colName;
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
if (isPrimaryKey)
      {
        tmpPriKey += delim + colName;
      }
      else
      {
        tmpForKey += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String DataType() throws ParseException {Token size;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INT:{
      jj_consume_token(INT);
{if ("" != null) return "int";}
      break;
      }
    case CHAR:{
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT_VALUE:{
        size = jj_consume_token(INT_VALUE);
        break;
        }
      case DIGIT:{
        size = jj_consume_token(DIGIT);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RIGHT_PAREN);
if (Integer.parseInt(size.image) <= 0) CharLengthError();
      {if ("" != null) return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";}
      break;
      }
    case DATE:{
      jj_consume_token(DATE);
{if ("" != null) return "date";}
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String TableName() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEGAL_IDENTIFIER:{
      t = jj_consume_token(LEGAL_IDENTIFIER);
if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
      }
    case ALPHABET:{
      t = jj_consume_token(ALPHABET);
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEGAL_IDENTIFIER:{
      t = jj_consume_token(LEGAL_IDENTIFIER);
if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
      }
    case ALPHABET:{
      t = jj_consume_token(ALPHABET);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public int DropTableQuery() throws ParseException {String tblName;
    jj_consume_token(DROP_TABLE);
    tblName = TableName();
if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else if (CheckDropReferencedTable(tblName))
    {
      DropReferencedTableError(tblName);
    }
    else
    {
      dropTblName = tblName;
      DropTable(tblName);
    }
    {if ("" != null) return 1;}
    throw new Error("Missing return statement in function");
  }

  final public int ShowTablesQuery() throws ParseException {
    jj_consume_token(SHOW_TABLES);
if (CheckShowTablesNoTable())
    {
      ShowTablesNoTable();
    }
    else
    {
      ShowTables();
    }
    {if ("" != null) return 2;}
    throw new Error("Missing return statement in function");
  }

  final public int DescQuery() throws ParseException {String tblName;
    jj_consume_token(DESC);
    tblName = TableName();
if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else
    {
      Describe(tblName);
    }
    {if ("" != null) return 3;}
    throw new Error("Missing return statement in function");
  }

  final public int SelectQuery() throws ParseException {unkown_tuple_space =new HashSet<HashMap<String,String>> ();
  Vector<String> alias_vector = new Vector<String>();
  HashSet<HashMap<String,String>> result ;
  tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>
    jj_consume_token(SELECT);
    SelectList(alias_vector);
    result = TableExpression();
CheckAndModifyAliasVector(alias_vector);
    result.removeAll(unkown_tuple_space);

    if(result.size() != 0)
    { ShowTuples(alias_vector, result); }
    else { System.out.println("Empty set");}

    {if ("" != null) return 4;}
    throw new Error("Missing return statement in function");
  }

  final public void SelectList(Vector<String> alias_vector) throws ParseException {selectedColumn_table = new Hashtable<String,String>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 3:{
      jj_consume_token(3);

      break;
      }
    case ALPHABET:
    case LEGAL_IDENTIFIER:{
      SelectedColumn(alias_vector);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        SelectedColumn(alias_vector);
      }
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SelectedColumn(Vector<String> alias_vector) throws ParseException {String alias = "";
    if (jj_2_2(2147483647)) {
      alias = SelectedColumnAux1();
alias_vector.add(alias);
    } else if (jj_2_3(2147483647)) {
      alias = SelectedColumnAux2();
alias_vector.add(alias);
    } else if (jj_2_4(2147483647)) {
      alias = SelectedColumnAux3();
alias_vector.add(alias);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        alias = ColumnName();
selectedColumn_table.put(alias,alias);
    alias_vector.add(alias);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public String SelectedColumnAux1() throws ParseException {String tblName = "";
   String colName = "" ; String alias ="";
    tblName = TableName();
    jj_consume_token(PERIOD);
    colName = ColumnName();
    jj_consume_token(AS);
    alias = ColumnName();
selectedColumn_table.put(alias,tblName+"."+colName);
         {if ("" != null) return alias;}
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumnAux2() throws ParseException {String tblName = "";
  String colName = "" ; String alias ="";
    tblName = TableName();
    jj_consume_token(PERIOD);
    colName = ColumnName();
alias = tblName+"."+colName;
    selectedColumn_table.put(alias,alias);
    {if ("" != null) return alias;}
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumnAux3() throws ParseException {String colName = "" ; String alias ="";
    colName = ColumnName();
    jj_consume_token(AS);
    alias = ColumnName();
selectedColumn_table.put(alias,colName); {if ("" != null) return alias ;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> TableExpression() throws ParseException {HashSet<HashMap<String,String>> result = new  HashSet<HashMap<String,String>>();
    if (jj_2_5(2147483647)) {
      FromClause();
      result = WhereClause();
{if ("" != null) return result;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FROM:{
        FromClause();
{if ("" != null) return tuple_space;}
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void FromClause() throws ParseException {alias_table = new Hashtable<String,String>();
  tuple_space =new HashSet<HashMap<String,String>> ();
  tblname_table = new Hashtable<String,String>();
    jj_consume_token(FROM);
    TableReferenceList();

  }

  final public void TableReferenceList() throws ParseException {String alias="";
    alias = ReferedTable();
ExtendTupleSpace(alias);  ExtendTableHash(alias);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      alias = ReferedTable();
ExtendTupleSpace(alias); ExtendTableHash(alias);
    }
  }

  final public String ReferedTable() throws ParseException {String alias = "";
  String tblName = "";
    if (jj_2_6(2147483647)) {
      tblName = TableName();
      jj_consume_token(AS);
      alias = TableName();
if (CheckNoSuchTable(tblName))
        {
          NoSuchTable();
        }

    if(alias_table.containsKey(alias)){
        NotUniqueAliasrError(alias );
    }

    alias_table.put(alias,tblName); {if ("" != null) return alias;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        tblName = TableName();
if (CheckNoSuchTable(tblName))
       {
         NoSuchTable();
       }
   alias_table.put(tblName,tblName);
   {if ("" != null) return tblName;}
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> WhereClause() throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
    jj_consume_token(WHERE);
    result = BooleanValueExpression();
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> BooleanValueExpression() throws ParseException {HashSet<HashMap<String,String>> result

 = new HashSet<HashMap<String,String>>();
     HashSet<HashMap<String,String>> tmp = new HashSet<HashMap<String,String>>();
    result = BooleanTerm();

    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_7;
      }
      jj_consume_token(OR);
      tmp = BooleanTerm();
result.addAll(tmp);
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> BooleanTerm() throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
   HashSet<HashMap<String,String>> tmp = new HashSet<HashMap<String,String>>();
    result = BooleanFactor();

    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
      jj_consume_token(AND);
      tmp = BooleanFactor();
result.retainAll(tmp); /* return result ; */

    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> BooleanFactor() throws ParseException {HashSet<HashMap<String,String>> temp = new HashSet<HashMap<String,String>>();
HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_PAREN:
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      result = BooleanTest();
{if ("" != null) return result;}
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      temp = BooleanTest();
result.addAll(tuple_space); result.removeAll(temp);{if ("" != null) return result;}
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> BooleanTest() throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      result = Predicate();
{if ("" != null) return result;}
      break;
      }
    case LEFT_PAREN:{
      result = ParentehsizedBooleanExpression();
{if ("" != null) return result;}
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> ParentehsizedBooleanExpression() throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
    jj_consume_token(LEFT_PAREN);
    result = BooleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> Predicate() throws ParseException {HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();
    if (jj_2_7(2147483647)) {
      result = ComparisonPredicate();
{if ("" != null) return result ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        result = NullPredicate();
{if ("" != null) return result;}
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> ComparisonPredicate() throws ParseException {String operand1 = "";
  String operand2 = "";
  Token operator;
  String operator_str ="";
  HashSet<HashMap<String,String>> result =  new HashSet<HashMap<String,String>>();
    operand1 = CompOperand();
    operator = jj_consume_token(COMP_OP);
operator_str = operator.image;
    operand2 = CompOperand();
result = FilterTuples(operand1, operand2, operator_str);
      {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String CompOperand() throws ParseException {String operand = "";
    if (jj_2_8(2147483647)) {
      operand = CompOperandAux();
Set<String> keySet = tblcol_table.keySet();
     if(!keySet.contains(operand)){ WhereColumnNotExistError(); }
     {if ("" != null) return operand;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        operand = ColumnName();
if(! tblname_table.containsKey(operand)) { WhereColumnNotExistError(); }
    else if (tblname_table.get(operand).equals("@duplication")){ WhereAmbiguousReferenceError(); }
    {if ("" != null) return tblname_table.get(operand)+"."+operand;}
        break;
        }
      case DIGIT:
      case INT_VALUE:
      case DATE_VALUE:
      case CHAR_STRING:{
        operand = ComparableValue_inWhereClause();
{if ("" != null) return operand;}
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String CompOperandAux() throws ParseException {String result = "";
  String TblName = "";
  String ColName = "";
    TblName = TableName();
    jj_consume_token(PERIOD);
    ColName = ColumnName();
if  (!alias_table.containsKey(TblName))
        {
         WhereTableNotSpecifiedError(); // talbe이 alias table 에 존재하는 지 본다 (alias가 없는 경우 자신의 이름으로 aliastable에 들어가 있다)
        }
   result = TblName+"."+ColName;
   {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String ComparableValue_inWhereClause() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DATE_VALUE:{
      t = jj_consume_token(DATE_VALUE);
{if ("" != null) return "d"+t.image.toLowerCase();}
      break;
      }
    case INT_VALUE:{
      t = jj_consume_token(INT_VALUE);
{if ("" != null) return "i"+t.image.toLowerCase();}
      break;
      }
    case DIGIT:{
      t = jj_consume_token(DIGIT);
{if ("" != null) return "i"+t.image.toLowerCase();}
      break;
      }
    case CHAR_STRING:{
      t = jj_consume_token(CHAR_STRING);
{if ("" != null) return "c"+t.image.toLowerCase();}
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ComparableValue() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DATE_VALUE:{
      t = jj_consume_token(DATE_VALUE);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case INT_VALUE:{
      t = jj_consume_token(INT_VALUE);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case DIGIT:{
      t = jj_consume_token(DIGIT);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case CHAR_STRING:{
      t = jj_consume_token(CHAR_STRING);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> NullPredicate() throws ParseException {HashSet<HashMap<String,String>> tuple_set_result = new HashSet<HashMap<String,String>> ();
String operand = ""; String condition ="";
    if (jj_2_9(2147483647)) {
      operand = NullPredicateAux();
Set<String> keySet = tblcol_table.keySet();
                                   if(!keySet.contains(operand)){ WhereColumnNotExistError(); }
      tuple_set_result = NullOperation(operand);
{if ("" != null) return tuple_set_result;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        operand = ColumnName();
if(! tblname_table.containsKey(operand)) { WhereColumnNotExistError(); }
                                else if (tblname_table.get(operand).equals("@duplication")){ WhereAmbiguousReferenceError(); }
                                operand = tblname_table.get(operand)+"."+operand;
        tuple_set_result = NullOperation(operand);
{if ("" != null) return tuple_set_result;}
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String NullPredicateAux() throws ParseException {String result = "";
   String tblName = "";
   String ColName = "";
    tblName = TableName();
    jj_consume_token(PERIOD);
    ColName = ColumnName();
if (CheckNoSuchTable(tblName))
         {
           NoSuchTable();
         }                          // COME BACK
     result = tblName+"."+ColName; //윗단에서, 만약 이 result를 key로 갖는 value가 없는 경우엔 존재하지 않는 column임을 나타내는 에러를 띄운다
     {if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public HashSet<HashMap<String,String>> NullOperation(String operand) throws ParseException {HashSet<HashMap<String,String>> result_tuple_set = new HashSet<HashMap<String,String>> ();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IS_NULL:{
      jj_consume_token(IS_NULL);
for(HashMap<String,String> item : tuple_space){
                if( item.get(operand).equals("null")){
                    result_tuple_set.add(item);
                }
     }
     {if ("" != null) return result_tuple_set;}
      break;
      }
    case IS_NOT_NULL:{
      jj_consume_token(IS_NOT_NULL);
for(HashMap<String,String> item : tuple_space){
                     if(!item.get(operand).equals("null")){
                         result_tuple_set.add(item);
                     }
          }
          {if ("" != null) return result_tuple_set;}
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int InsertQuery() throws ParseException {createTblName = "";
  String tblName;
  String colName;
  tmpCols = "";
  tmpVals = "";
    jj_consume_token(INSERT_INTO);
    tblName = TableName();
    InsertColumnsAndSource();
myDB.deleteDB(tblName+" @tmptuple"); // 에러가 났을 경우 아직도 남아있을 수 있기 때문에..
    if (!CheckTableExistence(tblName))
        {
          NoSuchTable();
        }

    if ( (colName = CheckInsertColumnExistence(tblName)) !=
     null ) {
            InsertColumnExistenceError(colName);
        }

    if ( (CheckInsertTypeMismatch(tblName))){
            InsertTypeMismatchError();
    }

    if ( (colName = CheckInsertColumnNonNullable(tblName))!= null){
            InsertColumnNonNullableError(colName);
    }


    if ( CheckInsertDuplicatePrimaryKeyError(tblName)){
        InsertDuplicatePrimaryKeyError();
    }

    if ( !CheckInsertReferentialIntegrity(tblName)){
        InsertReferentialIntegrityError();
    }

   myDB.putDB(tblName + " @tuple", myDB.getDB(tblName+" @tmptuple").elementAt(0));
   {if ("" != null) return 5;}
    throw new Error("Missing return statement in function");
  }

  final public void InsertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_PAREN:{
      ColumnNameList_insertion();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    ValueList();
  }

  final public void ValueList() throws ParseException {String valName;
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    valName = Value();
{ //COMBAC
      tmpVals += delim + valName;
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      valName = Value();
{
        tmpVals += delim + valName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String Value() throws ParseException {Token t;
   String s = "";
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NULL:{
      t = jj_consume_token(NULL);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case DIGIT:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      s = ComparableValue();
{if ("" != null) return s.toLowerCase();}
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int DeleteQuery() throws ParseException {String tblName;

    Vector<String> alias_vector = new Vector<String>();
    HashSet<HashMap<String,String>> result ;
    tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>    alias_table = new Hashtable<String,String>();
    tuple_space =new HashSet<HashMap<String,String>> ();
    tblname_table = new Hashtable<String,String>();
    tblcol_table = new Hashtable<String,String>();
    unkown_tuple_space =new HashSet<HashMap<String,String>> ();
    jj_consume_token(DELETE_FROM);
    tblName = TableName();
alias_table.put(tblName,tblName);
    ExtendTupleSpace(tblName);
    ExtendTableHash(tblName);
    result = tuple_space;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHERE:{
      result = WhereClause();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
if (CheckNoSuchTable(tblName))
            {
              NoSuchTable();
            }
    result.removeAll(unkown_tuple_space);
    int count = DeleteTuples(tblName,result);
    System.out.println(count+" rows are deleted");
    {if ("" != null) return 6;}
    throw new Error("Missing return statement in function");
  }

  final public boolean IsKeyword(String s) throws ParseException {
{if ("" != null) return keywordSet.contains(s.toLowerCase());}
    throw new Error("Missing return statement in function");
  }

  final public void Success(int i) throws ParseException {
switch (i)
    {
      case 0 :
      CreateTableSuccess();
      break;
      case 1 :
      DropSuccess();
      break;
      case 4 :
      break;
      case 5 : System.out.println("The row is inserted.");
      break;
      case 6 :
      break;
      case - 1 : myDB.closeDB();
      System.exit(0);
      break;
    }
  }

  final public void Start() throws ParseException {Token t;
System.out.print("DB_2014-16962 > ");
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:{
        ;
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        break label_10;
      }
      Command();
    }
System.out.println("Syntax error");
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3R_13()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_33()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_27()
 {
    if (jj_3R_32()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_33()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_20()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_60()
 {
    if (jj_scan_token(IS_NOT_NULL)) return true;
    return false;
  }

  private boolean jj_3R_17()
 {
    if (jj_scan_token(WHERE)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_36()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    if (jj_scan_token(IS_NULL)) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    return false;
  }

  private boolean jj_3R_35()
 {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_38()
 {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_34()
 {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_22()
 {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_11()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_21()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_37()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_30()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    }
    return false;
  }

  private boolean jj_3R_19()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_31()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    if (jj_3R_11()) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_28()
 {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_26()
 {
    if (jj_3R_30()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_54()
 {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_53()
 {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  private boolean jj_3R_18()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_16()
 {
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_16()) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_56()
 {
    if (jj_3R_21()) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    }
    return false;
  }

  private boolean jj_3R_52()
 {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_27()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_25()
 {
    if (jj_scan_token(DATE)) return true;
    return false;
  }

  private boolean jj_3R_50()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_48()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  private boolean jj_3R_43()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_39()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    return false;
  }

  private boolean jj_3R_15()
 {
    if (jj_3R_11()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_24()
 {
    if (jj_scan_token(CHAR)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    if (jj_scan_token(CHAR_STRING)) return true;
    return false;
  }

  private boolean jj_3R_12()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_23()
 {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_46()
 {
    if (jj_scan_token(DIGIT)) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (jj_scan_token(INT_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_14()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (jj_scan_token(DATE_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_32()
 {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_40()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    if (jj_scan_token(NOT_NULL)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SimpleDBMSTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[35];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x6,0x106,0x80c00000,0x80c00000,0x1000,0x6080000,0x80000,0x6000000,0x1000,0x1000,0x8000,0x70000000,0x80000,0x80000,0x1000,0x80008,0x80000,0x0,0x1000,0x80000,0x0,0x0,0x88400,0x88400,0x80000,0x88000,0x8000,0x8000,0x80000,0x0,0x400,0x1000,0x8000,0x0,0x80c00000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x4807,0x4807,0x0,0x8000,0x8000,0x0,0x0,0x0,0x10000,0x0,0x8000,0x8000,0x0,0x8000,0x8000,0x10,0x0,0x8000,0x80,0x40,0x78100,0x78000,0x8000,0x78000,0x70000,0x70000,0x8000,0x600,0x0,0x0,0x72000,0x20,0x4807,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMS(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMS(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMS(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMS(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[51];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 35; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}


class myDatabase
{
  static Environment myDBEnvironment = null;
  static Database myDatabase = null;
  static Cursor myDBCursor = null;

  public static void openDB()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDBEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(true);
    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);
    myDBCursor = myDatabase.openCursor(null, null);
  }

  public static void closeDB()
  {
    if (myDBCursor != null) myDBCursor.close();
    if (myDatabase != null) myDatabase.close();
    if (myDBEnvironment != null) myDBEnvironment.close();
  }

  public static void putDB(String key, String value)
  {
    DatabaseEntry _key;
    DatabaseEntry _value;
    try
    {
      _key = new DatabaseEntry(key.getBytes("UTF-8"));
      _value = new DatabaseEntry(value.getBytes("UTF-8"));
      myDBCursor.put(_key, _value);
    }
    catch (DatabaseException de)
    {}
    catch (UnsupportedEncodingException e)
    {
      e.printStackTrace();
    }
  }

  public static Vector<String> getDB(String key)
  {
    Vector<String> valueSet = new Vector<String>();
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry foundValue = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);
      while (retVal == OperationStatus.SUCCESS)
      {
        String valueString = new String(foundValue.getData(), "UTF-8");
        valueSet.addElement(valueString);
        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);
      }
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
    return valueSet;
  }

    public static void deleteTupleDB(String key, String value)
    {
      Cursor cursor = null;
      try
      {
        DatabaseEntry foundKey = new DatabaseEntry();
        DatabaseEntry foundData = new DatabaseEntry();
        cursor = myDatabase.openCursor(null, null);
        cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
        do
        {
          String keyString = new String(foundKey.getData(), "UTF-8");
          String dataString = new String(foundData.getData(), "UTF-8");

          if(keyString.equals(key) && dataString.equals(value))
          { cursor.delete(); }
        }
        while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);
      }
      catch (Exception e)
      {}
      finally
      {
        cursor.close();
      }
    }

  public static void deleteDB(String key)
  {
    try
    {
      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));
      myDatabase.delete(null, theKey);
    }
    catch (Exception e)
    {}
  }

  // For debugging  public static void printDB()
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry();
      DatabaseEntry foundData = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
      do
      {
        String keyString = new String(foundKey.getData(), "UTF-8");
        String dataString = new String(foundData.getData(), "UTF-8");
        System.out.println("<" + keyString + ", " + dataString + ">");
      }
      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
  }
  // For DB error handling and drop table query  public static void deleteTable(String tblName)
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));
      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));
      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));
      myDatabase.delete(null, colDef);
      myDatabase.delete(null, priKey);
      myDatabase.delete(null, forKey);
    }
    catch (Exception e)
    {}
  }
}
