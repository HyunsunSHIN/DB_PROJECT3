/* SimpleDBMS.java */
/* Generated By:JavaCC: Do not edit this line. SimpleDBMS.java */
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Vector;
import java.util.StringTokenizer;
import java.io.File;
import java.io.UnsupportedEncodingException;


import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

public class SimpleDBMS implements SimpleDBMSConstants {
  static final String [] keywordList = new String []
  {
    "exit",
    "create",
    "table",
    "not",
    "null",
    "primary",
    "key",
    "foreign",
    "references",
    "int",
    "char",
    "date",
    "drop",
    "show",
    "tables",
    "desc",
    "select",
    "as",
    "from",
    "where",
    "and",
    "or",
    "is",
    "insert",
    "into",
    "values",
    "delete"
  };

  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));
  static myDatabase myDB = new myDatabase();
  static SimpleDBMS parser;
  static String tmpColDef = "";
  static String tmpPriKey = "";
  static String tmpForKey = "";
  static String tmpCols = "";
  static String tmpVals = "";
  static String delim = "|";
  static String createTblName = "";
  static String dropTblName = "";
  static Vector<String > tblNameList = new Vector<String >();

  public static void main(String args []) throws ParseException
  {
    myDB.openDB();
    parser = new SimpleDBMS(System.in);
    tblNameList = myDB.getDB("@table name");
    handleSyntaxError(parser);
  }



  public static void handleSyntaxError(SimpleDBMS parser)
  {
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    { System.out.println("Syntax error");
      myDB.deleteTable(createTblName);
      parser = new SimpleDBMS(System.in);
      handleSyntaxError(parser);
    }
  }

  public static void handleDBError(SimpleDBMS parser)
  {
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

// Checking Functions// Get column definition from DB and check duplicate columns  final public 

boolean CheckInsertReferentialIntegrity(String tblName) throws ParseException {
String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);
      Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");

       for (int i = 0; i < forKeys.size(); i++)
       {
            boolean reached_references = false;
            String referenced_tblName = "";
            Vector<String> forkey_vertor = new Vector<String>();
            Vector<String> forkey_vector_referenced = new Vector<String>();
            String forKeyStr = forKeys.elementAt(i);
            StringTokenizer st = new StringTokenizer(forKeyStr, delim);
            while (st.hasMoreTokens())
            {
              String tmp = st.nextToken();
              if (tmp.contains("references"))
              { referenced_tblName = tmp.substring(12); // referenced table 을 참조해야하기 때문에, 이  이후에 작업하도록 한다.
                reached_references= true;
              }
              else if(!reached_references)
              { forkey_vertor.addElement(tmp);
              }
              else
              {
                forkey_vector_referenced.addElement(tmp);
              }
            }

           Vector<String> tuples_possibly_referenced= myDB.getDB(referenced_tblName+" @tuple"); // referencing table의 tuple들을 모두 조사한다
           if(tuples_possibly_referenced.size() == 0 ){ {if ("" != null) return false;} }
           boolean found = true ;
           for(int n = 0; n < tuples_possibly_referenced.size() ; n++){
                String tupleString_to_Compare = tuples_possibly_referenced.elementAt(n);
                found = true;

                for(int j = 0 ; j < forkey_vertor.size() ; j++){
                             String forkey_value_referencing
                              = GetColumnValue(tupleString_input,forkey_vertor.elementAt(j));

                             String forkey_value_refered
                              = GetColumnValue(tupleString_to_Compare, forkey_vector_referenced.elementAt(j));

                              if(!forkey_value_refered.equals(forkey_value_referencing) && (forkey_value_referencing!= "null") ){
                              found = false; break;
                              }
                }
                if( found ){ break; } // 여기에 도달했다는 것은,
                 //특정 forein Key column들이 모두 같은 tuple을 발견했다는 것이다.
                 // 이게 발견 되어야만 다음 foreign key 를 조사할 수 있도록한다 바로 아래 코드가 그런 역할을 함
           }
           if(!found ){ {if ("" != null) return false;} }
       }
       {if ("" != null) return true;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertDuplicatePrimaryKeyError(String tblName) throws ParseException {
String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);
         String PriKeys ="";
         Vector<String> PriKeysVector = myDB.getDB(tblName + " @primary key");

        if(PriKeysVector.size() == 0){{if ("" != null) return false;}}
        else{ PriKeys = PriKeysVector.elementAt(0);}

        Vector<String> tuples = myDB.getDB(tblName+ " @tuple");

         if(tuples.size() == 0 ){ {if ("" != null) return false;}}
         for(int i = 0 ; i < tuples.size() ; i ++ ){

             StringTokenizer st = new StringTokenizer(PriKeys, delim);
             String tupleString = tuples.elementAt(i);

             boolean duplication_occur = true;

             while(st.hasMoreTokens()){
                String PriKey = st.nextToken();
                String Value = GetColumnValue(tupleString,PriKey);
                String Value_input = GetColumnValue(tupleString_input,PriKey);

                if(!Value.equals(Value_input)){ duplication_occur= false; break;  }
             }
             if( duplication_occur){ {if ("" != null) return true;} }
         }
     {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnNonNullable(String tblName) throws ParseException {
addNullExiplicitly(tblName);
        String tupleToCheck = myDB.getDB(tblName + " @tmptuple").elementAt(0);
        StringTokenizer st = new StringTokenizer(tupleToCheck, delim);

            while (st.hasMoreTokens())
            {
              String col_name = st.nextToken();
              String col_val = st.nextToken();
              if(col_val.equals("null") &&
               !IsColumnNullable(tblName, col_name)){
                 {if ("" != null) return col_name;}
              }
            }
        {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnExistence(String tblName) throws ParseException {
// tmpCols =>분리 & tblNAm @colDef의 Value가 포함하고있나?
        Vector<String> colNames = new Vector<String>();
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        StringTokenizer st = new StringTokenizer(colDef, delim);
        String replacer_tmpCols = "";

          while (st.hasMoreTokens())
            {
              String colName = st.nextToken();
              String colType = st.nextToken();
              colNames.addElement(colName);
              replacer_tmpCols = replacer_tmpCols.concat("|"+colName);
            }

        if(tmpCols.length() > 0 ){
             StringTokenizer st2 = new StringTokenizer(tmpCols.substring(1), delim);
                  while (st2.hasMoreTokens())
                  {
                    String colName = st2.nextToken();
                    if (!colNames.contains(colName))
                    {
                      {if ("" != null) return colName;}
                    }
                  }
        } else {  tmpCols = replacer_tmpCols; }
        {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertTypeMismatch(String tblName) throws ParseException {
StringTokenizer st1 = new StringTokenizer(tmpCols.substring(1), delim);
      StringTokenizer st2 = new StringTokenizer(tmpVals.substring(1), delim);
      String tupleInput = "";
      if(st1.countTokens() != st2.countTokens() ){
        {if ("" != null) return true;}
      }

                while (st1.hasMoreTokens())
                  {
                    String colName = st1.nextToken();
                    String colVal = st2.nextToken();
                    String colType = GetColumnType(tblName, colName);
                      if(colVal.equals("null")){
                      tupleInput += "|"+colName+"|"+colVal;
                      continue; }
                      if(colType.equals("int")){
                           try {
                                Integer.parseInt(colVal); }
                           catch (NumberFormatException e )
                           {
                                {if ("" != null) return true;}
                           }


                      } else if (colType.equals("date")){

                            String[] yyyymmdd_arr = colVal.split("-");
                            if( yyyymmdd_arr.length != 3 ){ {if ("" != null) return true;} }
                                for(int k = 0 ; k < 3 ; k ++ ){
                                    try {
                                            Integer.parseInt(yyyymmdd_arr[k]); }
                                            catch (NumberFormatException e ){
                                            {if ("" != null) return true;}
                                    }
                                }

                      } else if (colType.startsWith("char(")){
                        if (!colVal.startsWith("'") || !colVal.endsWith("'")){
                              {if ("" != null) return true;}
                          } else {
                            String lengthOfChar = colType.substring(5,colType.length()-1);
                                                         int lengthOfChar_int = Integer.parseInt(lengthOfChar);
                                                         if(colVal.length() > lengthOfChar_int+ 2)
                                                         { colVal = colVal.substring(0, Integer.parseInt(lengthOfChar)+1) + "'"; }
                          }
                      } else {
                        {if ("" != null) return true;}
                      }

                 tupleInput += "|"+colName+"|"+colVal;
                }

          myDB.putDB(tblName + " @tmptuple", tupleInput.substring(1));
     {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckDuplicateColumnDef(String tblName) throws ParseException {
Vector<String> tmp = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      if (tmp.contains(colName))
      {
        {if ("" != null) return true;}
      }
      else
      {
        tmp.addElement(colName);
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names from DB and check whether input table name exists in DB  final public boolean CheckTableExistence(String tblName) throws ParseException {
Vector<String> tables = myDB.getDB("@table name");
    {if ("" != null) return tables.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get primary key definition from this table and check whether it occurs more than one times  final public boolean CheckDuplicatePrimaryKeyDef(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    {if ("" != null) return priKeys.size() > 1;}
    throw new Error("Missing return statement in function");
  }

// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DB  final public String CheckNonExistingColumnDef(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> colNames = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      colNames.addElement(colName);
    }
    // Check primary key definition
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st2 = new StringTokenizer(priKeyStr, delim);
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        if (!colNames.contains(colName))
        {
          {if ("" != null) return colName;}
        }
      }
    }
    // Check foreign key definition
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st3 = new StringTokenizer(forKeyStr, delim);
      while (st3.hasMoreTokens())
      {
        String colName = st3.nextToken();
        if (colName.contains("references"))  // references 라는게 있으면, syntax 에러를 뱉어내기 위함인가?
        {
          break;
        }
        else if (!colNames.contains(colName))
        {
          {if ("" != null) return colName;}
        }
      }
    }
    {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names from this table and check whether those referenced tables are really exist  final public boolean CheckReferenceTableExistence(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> tblNames = myDB.getDB("@table name");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        refTblName = st.nextToken();
        if (refTblName.contains("references"))  // WHY THIS?
        {
          refTblName = refTblName.substring(12);
          break;
        }
      }
      if (!tblNames.contains(refTblName))
      {
        {if ("" != null) return true;}
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are not primary key of referenced table  final public boolean CheckReferenceNonPrimaryKey(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      Vector<String> refPriKeyCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      Vector<String> refPriKeys = myDB.getDB(refTblName + " @primary key");
      if (refPriKeys.size() > 0)
      {
        // Get primary key of referenced table
        String refPriKeyStr = refPriKeys.elementAt(0);
        StringTokenizer st2 = new StringTokenizer(refPriKeyStr, delim);
        while (st2.hasMoreTokens())
        {
          String refPriKeyColName = st2.nextToken();
          refPriKeyCols.addElement(refPriKeyColName);
        }
      }
      // Check whether all of referenced columns are primary key
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refPriKeyCols.contains(refCols.elementAt(j)))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are really exist in referenced table  final public boolean CheckReferenceColumnExistence(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      String refRealColDefStr = myDB.getDB(refTblName + " @column definition").elementAt(0);
      Vector<String> refRealColNames = new Vector<String>();
      StringTokenizer st2 = new StringTokenizer(refRealColDefStr, delim);
      // Get columns of referenced table
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        refRealColNames.addElement(colName);
      }
      // Check whether all of referenced columns exist in referenced table
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refRealColNames.contains(refCols.elementAt(j)))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get type of referenced columns and referencing columns and check whether types of both columns are same  final public boolean CheckReferenceType(String tblName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns and referencing columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> forCols = new Vector<String>();
      Vector<String> refCols = new Vector<String>();
      String refTblName = "";
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
        else
        {
          String forColName = tmpstr;
          forCols.addElement(forColName);
        }
      }
      // If number of referenced columns and referencing columns are different, type error
      if (refCols.size() != forCols.size())
      {
        {if ("" != null) return true;}
      }
      // Check type of these columns one by one
      else
      {
        for (int j = 0; j < refCols.size(); j++)
        {
          String forColType = GetColumnType(tblName, forCols.elementAt(j));
          String refColType = GetColumnType(refTblName, refCols.elementAt(j));
          if (!forColType.equals(refColType))
          {
            {if ("" != null) return true;}
          }
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names of DB and check whether this table exists  final public boolean CheckNoSuchTable(String tblName) throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    {if ("" != null) return !tblNames.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names of DB and check whether this table is referenced by other table  final public boolean CheckDropReferencedTable(String refTblName) throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    for (int i = 0; i < tblNames.size(); i++)
    {
      Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");
      for (int j = 0; j < forKeys.size(); j++)
      {
        String forKeyStr = forKeys.elementAt(j);
        StringTokenizer st = new StringTokenizer(forKeyStr, delim);
        String tmpTbl = "";
        while (st.hasMoreTokens())
        {
          String tmp = st.nextToken();
          if (tmp.contains("references"))
          {
            tmpTbl = tmp.substring(12);
            break;
          }
        }
        if (tmpTbl.equals(refTblName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether there is no table  final public boolean CheckShowTablesNoTable() throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    {if ("" != null) return (tblNames.size() == 0);}
    throw new Error("Missing return statement in function");
  }

// Error Functions  final public 
void InsertReferentialIntegrityError() throws ParseException {
System.out.println("Insertion has failed: Referential integrity violation");
    handleDBError(parser);
  }

  final public void InsertDuplicatePrimaryKeyError() throws ParseException {
System.out.println("Insertion has failed: Primary key duplication");
        handleDBError(parser);
  }

  final public void InsertColumnNonNullableError(String colName) throws ParseException {
System.out.println("Insertion has failed: '"+colName+"' is not nullable");
    handleDBError(parser);
  }

  final public void InsertTypeMismatchError() throws ParseException {
System.out.println("Insertion has failed: Primary key duplication");
    handleDBError(parser);
  }

  final public void InsertColumnExistenceError(String colName) throws ParseException {
System.out.println( "Insertion has failed: '"+colName+"' does not exist");
    handleDBError(parser);
  }

  final public void DuplicateColumnDefError(String tblName) throws ParseException {
System.out.println("Create table has failed: column definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void TableExistenceError() throws ParseException {
System.out.println("Create table has failed: table with the same name already exist");
    handleDBError(parser);
  }

  final public void CharLengthError() throws ParseException {
System.out.println("Char length should be > 0");
    handleDBError(parser);
  }

  final public void DuplicatePrimaryKeyDefError(String tblName) throws ParseException {
System.out.println("Create table has failed: primary key definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NonExistingColumnDefError(String tblName, String colName) throws ParseException {
System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTableExistenceError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non existing table");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceNonPrimaryKeyError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non primary key column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceColumnExistenceError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references non existing column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTypeError(String tblName) throws ParseException {
System.out.println("Create table has failed: foreign key references wrong type");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NoSuchTable() throws ParseException {
System.out.println("No such table");
    handleDBError(parser);
  }

  final public void DropReferencedTableError(String tblName) throws ParseException {
System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");
    handleDBError(parser);
  }

  final public void ShowTablesNoTable() throws ParseException {
System.out.println("There is no table");
    handleDBError(parser);
  }

// Utility Functions  final public 
String GetColumnValue(String tupleString, String colName) throws ParseException {
StringTokenizer st =  new StringTokenizer(tupleString, delim);
         while (st.hasMoreTokens())
                    {
                      String col_name = st.nextToken();
                      String col_val = st.nextToken();
                      if(col_name.equals(colName)){
                        {if ("" != null) return col_val;}
                      }
                    }
      {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void addNullExiplicitly(String tblName) throws ParseException {
String colValStr = myDB.getDB(tblName + " @tmptuple").elementAt(0);

            StringTokenizer st1 = new StringTokenizer(colValStr, delim);
            Vector<String> tmp = new Vector<String>();

              while (st1.hasMoreTokens())
                        {
                          String col_name = st1.nextToken();
                          String col_value = st1.nextToken();
                          tmp.addElement(col_name);
                        }

            String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
            StringTokenizer st = new StringTokenizer(colDef, delim);
            while (st.hasMoreTokens())
            {
              String colName = st.nextToken();
              String colType = st.nextToken();
              if (!tmp.contains(colName))
              {
                 colValStr += "|"+colName+"|null";
              }
            }

            myDB.deleteDB(tblName + " @tmptuple");
            myDB.putDB(tblName+" @tmptuple", colValStr);
  }

  final public boolean IsColumnNullable(String tblName, String colName) throws ParseException {
String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        st2.nextToken();
        {if ("" != null) return !st2.hasMoreTokens();}
      }
    }
    {if ("" != null) return false;} // never reached since the argument must be valid.

    throw new Error("Missing return statement in function");
  }

// Get type of column  final public String GetColumnType(String tblName, String colName) throws ParseException {
String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        {if ("" != null) return st2.nextToken();}
      }
    }
    {if ("" != null) return null;}
    throw new Error("Missing return statement in function");
  }

// Change columns of primary key to not null  final public void ChangeToNotNull(String tblName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      // Get primary keys
      Vector<String> priCols = new Vector<String>();
      String priKeyStr = priKeys.elementAt(0);
      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
      myDB.deleteDB(tblName + " @column definition");
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        priCols.addElement(st.nextToken());
      }
      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);
      String newColDef = "";
      // Change type of primary keys to not null by deleting and re-inserting primary key data
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        StringTokenizer st3 = new StringTokenizer(colType, "*");
        String realColType = st3.nextToken();
        if (priCols.contains(colName) && !st3.hasMoreTokens())
        {
          newColDef += "|" + colName + "|" + realColType + "*not null";
        }
        else
        {
          newColDef += "|" + colName + "|" + colType;
        }
      }
      myDB.putDB(tblName + " @column definition", newColDef.substring(1));
    }
  }

// Perform drop table query  final public void DropTable(String tblName) throws ParseException {
myDB.deleteTable(tblName);
    myDB.deleteDB("@table name");
    tblNameList.remove(tblName);
    for (int i = 0; i < tblNameList.size(); i++)
    {
      myDB.putDB("@table name", tblNameList.elementAt(i));
    }
  }

// Perform show tables query  final public void ShowTables() throws ParseException {
Vector<String> tblNames = myDB.getDB("@table name");
    System.out.println("-------------------------");
    for (int i = 0; i < tblNames.size(); i++)
    {
      System.out.println(tblNames.elementAt(i));
    }
    System.out.println("-------------------------");
  }

// Check whether given column is primary key column  final public boolean IsPrimaryKey(String tblName, String colName) throws ParseException {
Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.equals(colName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether given column is foreign key column  final public boolean IsForeignKey(String tblName, String colName) throws ParseException {
Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.contains("references"))
        {
          break;
        }
        else if (tmp.equals(colName))
        {
          {if ("" != null) return true;}
        }
      }
    }
    {if ("" != null) return false;}
    throw new Error("Missing return statement in function");
  }

// Perform desc query  final public void Describe(String tblName) throws ParseException {
String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    System.out.println("------------------------------------------------------------");
    System.out.println("table_name [" + tblName + "]");
    System.out.printf("%-25s%-15s%-10s%-10s\u005cn", "column_name", "type", "null", "key");
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      boolean isNotNull = false;
      boolean isPriKey = IsPrimaryKey(tblName, colName);
      boolean isForKey = IsForeignKey(tblName, colName);
      StringTokenizer st2 = new StringTokenizer(colType, "*");
      String realColType = st2.nextToken();
      if (st2.hasMoreTokens())
      {
        isNotNull = true;
      }
      System.out.printf("%-25s%-15s", colName, realColType);
      if (isNotNull)
      {
        System.out.printf("%-10s", "N");
      }
      else
      {
        System.out.printf("%-10s", "Y");
      }
      if (isPriKey && isForKey)
      {
        System.out.printf("%-10s\u005cn", "PRI/FOR");
      }
      else if (isPriKey)
      {
        System.out.printf("%-10s\u005cn", "PRI");
      }
      else if (isForKey)
      {
        System.out.printf("%-10s\u005cn", "FOR");
      }
      else
      {
        System.out.print("\u005cn");
      }
    }
    System.out.println("------------------------------------------------------------");
  }

// Success Functions  final public void CreateTableSuccess() throws ParseException {
System.out.println("'" + createTblName + "' table is created");
  }

  final public void DropSuccess() throws ParseException {
System.out.println("'" + dropTblName + "' table is dropped");
  }

// Parsing Functions  final public void Command() throws ParseException {
    QueryList();
  }

  final public void QueryList() throws ParseException {int i;
    label_1:
    while (true) {
      i = Query();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:{
        jj_consume_token(SEMICOLON);
Success(i);
        break;
        }
      case 1:
      case 2:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 1:{
          jj_consume_token(1);
          break;
          }
        case 2:{
          jj_consume_token(2);
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
Success(i);
          System.out.print("SQL_2011-11693 > ");
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
  }

  final public int Query() throws ParseException {int i;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CREATE_TABLE:{
      i = CreateTableQuery();
      break;
      }
    case DROP_TABLE:{
      i = DropTableQuery();
      break;
      }
    case SHOW_TABLES:{
      i = ShowTablesQuery();
      break;
      }
    case DESC:{
      i = DescQuery();
      break;
      }
    case SELECT:{
      i = SelectQuery();
      break;
      }
    case INSERT_INTO:{
      i = InsertQuery();
      break;
      }
    case DELETE_FROM:{
      i = DeleteQuery();
      break;
      }
    case EXIT:{
      i = ExitQuery();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return i;}
    throw new Error("Missing return statement in function");
  }

  final public int ExitQuery() throws ParseException {
    jj_consume_token(EXIT);
String result = myDB.getDB("account @primary key").elementAt(0);
    System.out.println(result);
    {if ("" != null) return - 1;}
    throw new Error("Missing return statement in function");
  }

  final public int CreateTableQuery() throws ParseException {String tblName;
  String colName;
    jj_consume_token(CREATE_TABLE);
    tblName = TableName();
if (CheckTableExistence(tblName))
    {
      TableExistenceError();
    }
    TableElementList(tblName);
myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));
    tmpColDef = "";
    tmpPriKey = "";
    tmpForKey = "";
    if (CheckDuplicateColumnDef(tblName))
    {
      DuplicateColumnDefError(tblName);
    }
    else if (CheckDuplicatePrimaryKeyDef(tblName))
    {
      DuplicatePrimaryKeyDefError(tblName);
    }
    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)
    {
      NonExistingColumnDefError(tblName, colName);
    }
    else if (CheckReferenceTableExistence(tblName))
    {
      ReferenceTableExistenceError(tblName);
    }
    else if (CheckReferenceColumnExistence(tblName))
    {
      ReferenceColumnExistenceError(tblName);
    }
    else if (CheckReferenceNonPrimaryKey(tblName))
    {
      ReferenceNonPrimaryKeyError(tblName);
    }
    else if (CheckReferenceType(tblName))
    {
      ReferenceTypeError(tblName);
    }

    ChangeToNotNull(tblName);
    createTblName = tblName;
    myDB.putDB("@table name", tblName);
    tblNameList.addElement(tblName);
    {if ("" != null) return 0;}
    throw new Error("Missing return statement in function");
  }

  final public void TableElementList(String tblName) throws ParseException {
    jj_consume_token(LEFT_PAREN);
    TableElement(tblName);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      TableElement(tblName);
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ALPHABET:
    case LEGAL_IDENTIFIER:{
      ColumnDefinition();
      break;
      }
    case PRIMARY_KEY:
    case FOREIGN_KEY:{
      TableConstraintDefinition(tblName);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException {String colName = "";
  String dataType = "";
  String notNull = "";
    if (jj_2_1(2147483647)) {
      colName = ColumnName();
      dataType = DataType();
      jj_consume_token(NOT_NULL);
notNull = "*not null";
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        colName = ColumnName();
        dataType = DataType();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
tmpColDef += delim + colName + delim + dataType + notNull;
  }

  final public void TableConstraintDefinition(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIMARY_KEY:{
      PrimaryKeyConstraint(tblName);
      break;
      }
    case FOREIGN_KEY:{
      ReferentialKeyConstraint(tblName);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint(String tblName) throws ParseException {
    jj_consume_token(PRIMARY_KEY);
    ColumnNameList(true);
myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));
  }

  final public void ReferentialKeyConstraint(String tblName) throws ParseException {String referedTblName;
    jj_consume_token(FOREIGN_KEY);
    ColumnNameList(false);
    jj_consume_token(REFERENCES);
    referedTblName = TableName();
tmpForKey += delim + "@references&" + referedTblName;
    ColumnNameList(false);
myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));
    tmpForKey = "";
  }

  final public void ColumnNameList_insertion() throws ParseException {String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
{
      tmpCols += delim + colName;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
{
        tmpCols += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void ColumnNameList(boolean isPrimaryKey) throws ParseException {String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
if (isPrimaryKey)
    {
      tmpPriKey += delim + colName;
    }
    else
    {
      tmpForKey += delim + colName;
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
if (isPrimaryKey)
      {
        tmpPriKey += delim + colName;
      }
      else
      {
        tmpForKey += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String DataType() throws ParseException {Token size;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INT:{
      jj_consume_token(INT);
{if ("" != null) return "int";}
      break;
      }
    case CHAR:{
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INT_VALUE:{
        size = jj_consume_token(INT_VALUE);
        break;
        }
      case DIGIT:{
        size = jj_consume_token(DIGIT);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RIGHT_PAREN);
if (Integer.parseInt(size.image) <= 0) CharLengthError();
      {if ("" != null) return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";}
      break;
      }
    case DATE:{
      jj_consume_token(DATE);
{if ("" != null) return "date";}
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String TableName() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEGAL_IDENTIFIER:{
      t = jj_consume_token(LEGAL_IDENTIFIER);
if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
      }
    case ALPHABET:{
      t = jj_consume_token(ALPHABET);
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEGAL_IDENTIFIER:{
      t = jj_consume_token(LEGAL_IDENTIFIER);
if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
      }
    case ALPHABET:{
      t = jj_consume_token(ALPHABET);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public int DropTableQuery() throws ParseException {String tblName;
    jj_consume_token(DROP_TABLE);
    tblName = TableName();
if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else if (CheckDropReferencedTable(tblName))
    {
      DropReferencedTableError(tblName);
    }
    else
    {
      dropTblName = tblName;
      DropTable(tblName);
    }
    {if ("" != null) return 1;}
    throw new Error("Missing return statement in function");
  }

  final public int ShowTablesQuery() throws ParseException {
    jj_consume_token(SHOW_TABLES);
if (CheckShowTablesNoTable())
    {
      ShowTablesNoTable();
    }
    else
    {
      ShowTables();
    }
    {if ("" != null) return 2;}
    throw new Error("Missing return statement in function");
  }

  final public int DescQuery() throws ParseException {String tblName;
    jj_consume_token(DESC);
    tblName = TableName();
if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else
    {
      Describe(tblName);
    }
    {if ("" != null) return 3;}
    throw new Error("Missing return statement in function");
  }

  final public int SelectQuery() throws ParseException {
    jj_consume_token(SELECT);
    SelectList();
    TableExpression();
{if ("" != null) return 4;}
    throw new Error("Missing return statement in function");
  }

  final public void SelectList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 3:{
      jj_consume_token(3);
      break;
      }
    case ALPHABET:
    case LEGAL_IDENTIFIER:{
      SelectedColumn();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        SelectedColumn();
      }
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SelectedColumn() throws ParseException {
    if (jj_2_2(2147483647)) {
      SelectedColumnAux1();
    } else if (jj_2_3(2147483647)) {
      SelectedColumnAux2();
    } else if (jj_2_4(2147483647)) {
      SelectedColumnAux3();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        ColumnName();
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void SelectedColumnAux1() throws ParseException {
    TableName();
    jj_consume_token(PERIOD);
    ColumnName();
    jj_consume_token(AS);
    ColumnName();
  }

  final public void SelectedColumnAux2() throws ParseException {
    TableName();
    jj_consume_token(PERIOD);
    ColumnName();
  }

  final public void SelectedColumnAux3() throws ParseException {
    ColumnName();
    jj_consume_token(AS);
    ColumnName();
  }

  final public void TableExpression() throws ParseException {
    if (jj_2_5(2147483647)) {
      FromClause();
      WhereClause();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FROM:{
        FromClause();
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void FromClause() throws ParseException {
    jj_consume_token(FROM);
    TableReferenceList();
  }

  final public void TableReferenceList() throws ParseException {
    ReferedTable();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      ReferedTable();
    }
  }

  final public void ReferedTable() throws ParseException {
    if (jj_2_6(2147483647)) {
      TableName();
      jj_consume_token(AS);
      TableName();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        TableName();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void WhereClause() throws ParseException {
    jj_consume_token(WHERE);
    BooleanValueExpression();
  }

  final public void BooleanValueExpression() throws ParseException {
    BooleanTerm();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_7;
      }
      jj_consume_token(OR);
      BooleanTerm();
    }
  }

  final public void BooleanTerm() throws ParseException {
    BooleanFactor();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
      jj_consume_token(AND);
      BooleanFactor();
    }
  }

  final public void BooleanFactor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_PAREN:
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      BooleanTest();
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      BooleanTest();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void BooleanTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      Predicate();
      break;
      }
    case LEFT_PAREN:{
      ParentehsizedBooleanExpression();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParentehsizedBooleanExpression() throws ParseException {
    jj_consume_token(LEFT_PAREN);
    BooleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
  }

  final public void Predicate() throws ParseException {
    if (jj_2_7(2147483647)) {
      ComparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        NullPredicate();
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ComparisonPredicate() throws ParseException {
    CompOperand();
    jj_consume_token(COMP_OP);
    CompOperand();
  }

  final public void CompOperand() throws ParseException {
    if (jj_2_8(2147483647)) {
      CompOperandAux();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        ColumnName();
        break;
        }
      case DIGIT:
      case INT_VALUE:
      case DATE_VALUE:
      case CHAR_STRING:{
        ComparableValue();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void CompOperandAux() throws ParseException {
    TableName();
    jj_consume_token(PERIOD);
    ColumnName();
  }

  final public String ComparableValue() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DATE_VALUE:{
      t = jj_consume_token(DATE_VALUE);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case INT_VALUE:{
      t = jj_consume_token(INT_VALUE);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case DIGIT:{
      t = jj_consume_token(DIGIT);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case CHAR_STRING:{
      t = jj_consume_token(CHAR_STRING);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NullPredicate() throws ParseException {
    if (jj_2_9(2147483647)) {
      NullPredicateAux();
      NullOperation();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:{
        ColumnName();
        NullOperation();
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void NullPredicateAux() throws ParseException {
    TableName();
    jj_consume_token(PERIOD);
    ColumnName();
  }

  final public void NullOperation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IS_NULL:{
      jj_consume_token(IS_NULL);
      break;
      }
    case IS_NOT_NULL:{
      jj_consume_token(IS_NOT_NULL);
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public int InsertQuery() throws ParseException {createTblName = "";
  String tblName;
  String colName;
  tmpCols = "";
  tmpVals = "";
    jj_consume_token(INSERT_INTO);
    tblName = TableName();
    InsertColumnsAndSource();
myDB.deleteDB(tblName+" @tmptuple"); // 에러가 났을 경우 아직도 남아있을 수 있기 때문에..
    if (!CheckTableExistence(tblName))
        {
          NoSuchTable();
        }

    if ( (colName = CheckInsertColumnExistence(tblName)) !=
     null ) {
            InsertColumnExistenceError(colName);
        }

    if ( (CheckInsertTypeMismatch(tblName))){
            InsertTypeMismatchError();
    }

    if ( (colName = CheckInsertColumnNonNullable(tblName))!= null){
            InsertColumnNonNullableError(colName);
    }


    if ( CheckInsertDuplicatePrimaryKeyError(tblName)){
        InsertDuplicatePrimaryKeyError();
    }

    if ( !CheckInsertReferentialIntegrity(tblName)){
        InsertReferentialIntegrityError();
    }

   myDB.putDB(tblName + " @tuple", myDB.getDB(tblName+" @tmptuple").elementAt(0));
   {if ("" != null) return 5;}
    throw new Error("Missing return statement in function");
  }

  final public void InsertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEFT_PAREN:{
      ColumnNameList_insertion();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    ValueList();
  }

  final public void ValueList() throws ParseException {String valName;
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    valName = Value();
{ //COMBAC
      tmpVals += delim + valName;
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      valName = Value();
{
        tmpVals += delim + valName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String Value() throws ParseException {Token t;
   String s = "";
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NULL:{
      t = jj_consume_token(NULL);
{if ("" != null) return t.image.toLowerCase();}
      break;
      }
    case DIGIT:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:{
      s = ComparableValue();
{if ("" != null) return s.toLowerCase();}
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int DeleteQuery() throws ParseException {
    jj_consume_token(DELETE_FROM);
    TableName();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHERE:{
      WhereClause();
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      ;
    }
{if ("" != null) return 6;}
    throw new Error("Missing return statement in function");
  }

  final public boolean IsKeyword(String s) throws ParseException {
{if ("" != null) return keywordSet.contains(s.toLowerCase());}
    throw new Error("Missing return statement in function");
  }

  final public void Success(int i) throws ParseException {
switch (i)
    {
      case 0 :
      CreateTableSuccess();
      break;
      case 1 :
      DropSuccess();
      break;
      case 4 : System.out.println("select requested");
      break;
      case 5 : System.out.println("insert requested");
      break;
      case 6 : System.out.println("delete requested");
      break;
      case - 1 : myDB.closeDB();
      System.exit(0);
      break;
    }
  }

  final public void Start() throws ParseException {Token t;
System.out.print("SQL_2011-11693 > ");
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXIT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:{
        ;
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        break label_10;
      }
      Command();
    }
System.out.println("Syntax error");
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3R_26()
 {
    if (jj_3R_30()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_31()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_46()
 {
    if (jj_scan_token(DIGIT)) return true;
    return false;
  }

  private boolean jj_3R_12()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_23()
 {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (jj_scan_token(INT_VALUE)) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_16()) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (jj_scan_token(DATE_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_16()
 {
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    if (jj_scan_token(NOT_NULL)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_20()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_36()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_35()
 {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_15()
 {
    if (jj_3R_11()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_34()
 {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_14()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_19()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_54()
 {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_13()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_53()
 {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_52()
 {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_27()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_50()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_22()
 {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_48()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  private boolean jj_3R_11()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_43()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_39()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    return false;
  }

  private boolean jj_3R_40()
 {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_32()
 {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_40()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_28()
 {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_33()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_18()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_27()
 {
    if (jj_3R_32()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_33()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_58()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_17()
 {
    if (jj_scan_token(WHERE)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_21()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_25()
 {
    if (jj_scan_token(DATE)) return true;
    return false;
  }

  private boolean jj_3R_38()
 {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    if (jj_3R_11()) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_37()
 {
    if (jj_3R_18()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_30()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    }
    return false;
  }

  private boolean jj_3R_56()
 {
    if (jj_3R_21()) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    }
    return false;
  }

  private boolean jj_3R_31()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_24()
 {
    if (jj_scan_token(CHAR)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    if (jj_scan_token(CHAR_STRING)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SimpleDBMSTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[34];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x6,0x106,0x80c00000,0x80c00000,0x1000,0x6080000,0x80000,0x6000000,0x1000,0x1000,0x8000,0x70000000,0x80000,0x80000,0x1000,0x80008,0x80000,0x0,0x1000,0x80000,0x0,0x0,0x88400,0x88400,0x80000,0x88000,0x8000,0x80000,0x0,0x400,0x1000,0x8000,0x0,0x80c00000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x4807,0x4807,0x0,0x8000,0x8000,0x0,0x0,0x0,0x10000,0x0,0x8000,0x8000,0x0,0x8000,0x8000,0x10,0x0,0x8000,0x80,0x40,0x78100,0x78000,0x8000,0x78000,0x70000,0x8000,0x600,0x0,0x0,0x72000,0x20,0x4807,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMS(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMS(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMS(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMS(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[51];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 34; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}


class myDatabase
{
  static Environment myDBEnvironment = null;
  static Database myDatabase = null;
  static Cursor myDBCursor = null;

  public static void openDB()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDBEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(true);
    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);
    myDBCursor = myDatabase.openCursor(null, null);
  }

  public static void closeDB()
  {
    if (myDBCursor != null) myDBCursor.close();
    if (myDatabase != null) myDatabase.close();
    if (myDBEnvironment != null) myDBEnvironment.close();
  }

  public static void putDB(String key, String value)
  {
    DatabaseEntry _key;
    DatabaseEntry _value;
    try
    {
      _key = new DatabaseEntry(key.getBytes("UTF-8"));
      _value = new DatabaseEntry(value.getBytes("UTF-8"));
      myDBCursor.put(_key, _value);
    }
    catch (DatabaseException de)
    {}
    catch (UnsupportedEncodingException e)
    {
      e.printStackTrace();
    }
  }

  public static Vector<String> getDB(String key)
  {
    Vector<String> valueSet = new Vector<String>();
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry foundValue = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);
      while (retVal == OperationStatus.SUCCESS)
      {
        String valueString = new String(foundValue.getData(), "UTF-8");
        valueSet.addElement(valueString);
        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);
      }
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
    return valueSet;
  }

  public static void deleteDB(String key)
  {
    try
    {
      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));
      myDatabase.delete(null, theKey);
    }
    catch (Exception e)
    {}
  }

  // For debugging  public static void printDB()
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry();
      DatabaseEntry foundData = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
      do
      {
        String keyString = new String(foundKey.getData(), "UTF-8");
        String dataString = new String(foundData.getData(), "UTF-8");
        System.out.println("<" + keyString + ", " + dataString + ">");
      }
      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
  }
  // For DB error handling and drop table query  public static void deleteTable(String tblName)
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));
      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));
      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));
      myDatabase.delete(null, colDef);
      myDatabase.delete(null, priKey);
      myDatabase.delete(null, forKey);
    }
    catch (Exception e)
    {}
  }
}
