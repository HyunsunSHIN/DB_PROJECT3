/** * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+ */options{  static = false;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMS)import java.util.Set;import java.util.HashMap;import java.util.HashSet;import java.util.Hashtable;import java.util.stream.Stream;import java.util.Arrays;import java.util.Vector;import java.util.StringTokenizer;import java.io.File;import java.io.UnsupportedEncodingException;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;public class SimpleDBMS{  static final String [] keywordList = new String []  {    "exit",    "create",    "table",    "not",    "null",    "primary",    "key",    "foreign",    "references",    "int",    "char",    "date",    "drop",    "show",    "tables",    "desc",    "select",    "as",    "from",    "where",    "and",    "or",    "is",    "insert",    "into",    "values",    "delete"  };  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));  static myDatabase myDB = new myDatabase();  static SimpleDBMS parser;  static String tmpColDef = "";  static String tmpPriKey = "";  static String tmpForKey = "";  static String tmpCols = "";  static String tmpVals = "";  static String delim = "|";  static String createTblName = "";  static String dropTblName = "";  static Vector<String > tblNameList = new Vector<String >();  static Hashtable<String,String> alias_table = new Hashtable<String,String>();  static HashSet<HashMap<String,String>> tuple_space =new HashSet<HashMap<String,String>> ();  static Hashtable <String, String> tblname_table = new Hashtable<String,String>(); //<K,V> = <colName, alias> OR <colName, @dupliacation>  static Hashtable <String, String> tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>  static Hashtable <String, String> selectedColumn_table = new Hashtable<String,String>(); // <K,V> = <alias, tblName.colName)  public static void main(String args []) throws ParseException  {    myDB.openDB();    parser = new SimpleDBMS(System.in);    tblNameList = myDB.getDB("@table name");    handleSyntaxError(parser);  }  public static void handleSyntaxError(SimpleDBMS parser)  {    try    {      parser.Start();    }    catch (ParseException e)    { System.out.println("Syntax error");      myDB.deleteTable(createTblName);      parser = new SimpleDBMS(System.in);      handleSyntaxError(parser);    }  }  public static void handleDBError(SimpleDBMS parser)  {    parser = new SimpleDBMS(System.in);    handleSyntaxError(parser);  }}class myDatabase{  static Environment myDBEnvironment = null;  static Database myDatabase = null;  static Cursor myDBCursor = null;  public static void openDB()  {    EnvironmentConfig envConfig = new EnvironmentConfig();    envConfig.setAllowCreate(true);    myDBEnvironment = new Environment(new File("db/"), envConfig);    DatabaseConfig dbConfig = new DatabaseConfig();    dbConfig.setAllowCreate(true);    dbConfig.setSortedDuplicates(true);    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);    myDBCursor = myDatabase.openCursor(null, null);  }  public static void closeDB()  {    if (myDBCursor != null) myDBCursor.close();    if (myDatabase != null) myDatabase.close();    if (myDBEnvironment != null) myDBEnvironment.close();  }  public static void putDB(String key, String value)  {    DatabaseEntry _key;    DatabaseEntry _value;    try    {      _key = new DatabaseEntry(key.getBytes("UTF-8"));      _value = new DatabaseEntry(value.getBytes("UTF-8"));      myDBCursor.put(_key, _value);    }    catch (DatabaseException de)    {}    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }  }  public static Vector<String> getDB(String key)  {    Vector<String> valueSet = new Vector<String>();    Cursor cursor = null;    try    {      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));      DatabaseEntry foundValue = new DatabaseEntry();      cursor = myDatabase.openCursor(null, null);      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);      while (retVal == OperationStatus.SUCCESS)      {        String valueString = new String(foundValue.getData(), "UTF-8");        valueSet.addElement(valueString);        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);      }    }    catch (Exception e)    {}    finally    {      cursor.close();    }    return valueSet;  }    public static void deleteTupleDB(String key, String value)    {      Cursor cursor = null;      try      {        DatabaseEntry foundKey = new DatabaseEntry();        DatabaseEntry foundData = new DatabaseEntry();        cursor = myDatabase.openCursor(null, null);        cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);        do        {          String keyString = new String(foundKey.getData(), "UTF-8");          String dataString = new String(foundData.getData(), "UTF-8");          if(keyString.equals(key) && dataString.equals(value))          { cursor.delete(); }        }        while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);      }      catch (Exception e)      {}      finally      {        cursor.close();      }    }  public static void deleteDB(String key)  {    try    {      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));      myDatabase.delete(null, theKey);    }    catch (Exception e)    {}  }  // For debugging  public static void printDB()  {    Cursor cursor = null;    try    {      DatabaseEntry foundKey = new DatabaseEntry();      DatabaseEntry foundData = new DatabaseEntry();      cursor = myDatabase.openCursor(null, null);      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);      do      {        String keyString = new String(foundKey.getData(), "UTF-8");        String dataString = new String(foundData.getData(), "UTF-8");        System.out.println("<" + keyString + ", " + dataString + ">");      }      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);    }    catch (Exception e)    {}    finally    {      cursor.close();    }  }  // For DB error handling and drop table query  public static void deleteTable(String tblName)  {    Cursor cursor = null;    try    {      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));      myDatabase.delete(null, colDef);      myDatabase.delete(null, priKey);      myDatabase.delete(null, forKey);    }    catch (Exception e)    {}  }}PARSER_END(SimpleDBMS)// Checking Functions// Get column definition from DB and check duplicate columnsboolean CheckInsertReferentialIntegrity(String tblName): //integerity 성립 시 true를 반환.{}{    { String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);      Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");       for (int i = 0; i < forKeys.size(); i++)       {            boolean reached_references = false;            String referenced_tblName = "";            Vector<String> forkey_vertor = new Vector<String>();            Vector<String> forkey_vector_referenced = new Vector<String>();            String forKeyStr = forKeys.elementAt(i);            StringTokenizer st = new StringTokenizer(forKeyStr, delim);            while (st.hasMoreTokens())            {              String tmp = st.nextToken();              if (tmp.contains("references"))              { referenced_tblName = tmp.substring(12); // referenced table 을 참조해야하기 때문에, 이  이후에 작업하도록 한다.                reached_references= true;              }              else if(!reached_references)              { forkey_vertor.addElement(tmp);              }              else              {                forkey_vector_referenced.addElement(tmp);              }            }           Vector<String> tuples_possibly_referenced= myDB.getDB(referenced_tblName+" @tuple"); // referencing table의 tuple들을 모두 조사한다           if(tuples_possibly_referenced.size() == 0 ){ return false; }           boolean found = true ;           for(int n = 0; n < tuples_possibly_referenced.size() ; n++){                String tupleString_to_Compare = tuples_possibly_referenced.elementAt(n);                found = true;                for(int j = 0 ; j < forkey_vertor.size() ; j++){                             String forkey_value_referencing                              = GetColumnValue(tupleString_input,forkey_vertor.elementAt(j));                             String forkey_value_refered                              = GetColumnValue(tupleString_to_Compare, forkey_vector_referenced.elementAt(j));                              if(forkey_value_referencing.equals("null")){ return false; } // foreign key 가 null인 경우, 조사할 필요가 없다.                              if(!forkey_value_refered.equals(forkey_value_referencing) && (forkey_value_referencing!= "null") ){                              found = false; break;                              }                }                if( found ){ break; } // 여기에 도달했다는 것은,                 // 특정 forein Key column들이 모두 같은 tuple을 발견했다는 것이다. 그러므로 다른 tuple들을 조사할 필요가 없으므로                 // break를 시켜준다 또한 found 가 ture일 때에만                 // 이게 발견 되어야만 다음 foreign key 를 조사할 수 있도록한다 바로 아래 코드가 그런 역할을 한다           }           if(!found ){ return false; }       }       return true;    }}boolean CheckInsertDuplicatePrimaryKeyError(String tblName):{}{    {         String tupleString_input = myDB.getDB(tblName + " @tmptuple").elementAt(0);         String PriKeys ="";         Vector<String> PriKeysVector = myDB.getDB(tblName + " @primary key");        if( PriKeysVector.size() == 0 ){return false;}        else{ PriKeys = PriKeysVector.elementAt(0);}        Vector<String> tuples = myDB.getDB(tblName+ " @tuple");         if(tuples.size() == 0 ){ return false;}         for(int i = 0 ; i < tuples.size() ; i ++ ){             StringTokenizer st = new StringTokenizer(PriKeys, delim);             String tupleString = tuples.elementAt(i);             boolean duplication_occur = true;             while(st.hasMoreTokens()){                String PriKey = st.nextToken();                String Value = GetColumnValue(tupleString,PriKey);                String Value_input = GetColumnValue(tupleString_input,PriKey);                if(!Value.equals(Value_input)){ duplication_occur= false; break;  }             }             if( duplication_occur){ return true; }         }     return false;    }}String CheckInsertColumnNonNullable(String tblName):{}{  {        addNullExiplicitly(tblName);        String tupleToCheck = myDB.getDB(tblName + " @tmptuple").elementAt(0);        StringTokenizer st = new StringTokenizer(tupleToCheck, delim);            while (st.hasMoreTokens())            {              String col_name = st.nextToken();              String col_val = st.nextToken();              if(col_val.equals("null") &&               !IsColumnNullable(tblName, col_name)){                 return col_name;              }            }        return null;  }}String CheckInsertColumnExistence(String tblName):{}{    { // tmpCols =>분리 & tblNAm @colDef의 Value가 포함하고있나?        Vector<String> colNames = new Vector<String>();        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);        StringTokenizer st = new StringTokenizer(colDef, delim);        String replacer_tmpCols = "";          while (st.hasMoreTokens())            {              String colName = st.nextToken();              String colType = st.nextToken();              colNames.addElement(colName);              replacer_tmpCols = replacer_tmpCols.concat("|"+colName);            }        if(tmpCols.length() > 0 ){             StringTokenizer st2 = new StringTokenizer(tmpCols.substring(1), delim);                  while (st2.hasMoreTokens())                  {                    String colName = st2.nextToken();                    if (!colNames.contains(colName))                    {                      return colName;                    }                  }        } else {  tmpCols = replacer_tmpCols; }        return null;    }}boolean CheckInsertTypeMismatch( String tblName ):{}{    { StringTokenizer st1 = new StringTokenizer(tmpCols.substring(1), delim);      StringTokenizer st2 = new StringTokenizer(tmpVals.substring(1), delim);      String tupleInput = "";      if(st1.countTokens() != st2.countTokens() ){        return true;      }                while (st1.hasMoreTokens())                  {                    String colName = st1.nextToken();                    String colVal = st2.nextToken();                    String colType = GetColumnType(tblName, colName);                      if(colVal.equals("null")){                      tupleInput += "|"+colName+"|"+colVal;                      continue; }                      if(colType.equals("int")){                           try {                                Integer.parseInt(colVal); }                           catch (NumberFormatException e )                           {                                return true;                           }                      } else if (colType.equals("date")){                            String[] yyyymmdd_arr = colVal.split("-");                            if( yyyymmdd_arr.length != 3 ){ return true; }                                for(int k = 0 ; k < 3 ; k ++ ){                                    try {                                            Integer.parseInt(yyyymmdd_arr[k]); }                                            catch (NumberFormatException e ){                                            return true;                                    }                                }                      } else if (colType.startsWith("char(")){                        if (!colVal.startsWith("'") || !colVal.endsWith("'")){                              return true;                          } else {                            String lengthOfChar = colType.substring(5,colType.length()-1);                                                         int lengthOfChar_int = Integer.parseInt(lengthOfChar);                                                         if(colVal.length() > lengthOfChar_int+ 2)                                                         { colVal = colVal.substring(0, Integer.parseInt(lengthOfChar)+1) + "'"; }                          }                      } else {                        return true;                      }                 tupleInput += "|"+colName+"|"+colVal;                }          myDB.putDB(tblName + " @tmptuple", tupleInput.substring(1));     return false;    }}boolean CheckDuplicateColumnDef(String tblName) :{}{  {    Vector<String> tmp = new Vector<String>();    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDef, delim);    while (st.hasMoreTokens())    {      String colName = st.nextToken();      String colType = st.nextToken();      if (tmp.contains(colName))      {        return true;      }      else      {        tmp.addElement(colName);      }    }    return false;  }}// Get table names from DB and check whether input table name exists in DBboolean CheckTableExistence(String tblName) :{}{  {    Vector<String> tables = myDB.getDB("@table name");    return tables.contains(tblName);  }}// Get primary key definition from this table and check whether it occurs more than one timesboolean CheckDuplicatePrimaryKeyDef(String tblName) :{}{  {    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");    return priKeys.size() > 1;  }}// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DBString CheckNonExistingColumnDef(String tblName) :{}{  {    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    Vector<String> colNames = new Vector<String>();    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDef, delim);    while (st.hasMoreTokens())    {      String colName = st.nextToken();      String colType = st.nextToken();      colNames.addElement(colName);    }    // Check primary key definition    if (priKeys.size() > 0)    {      String priKeyStr = priKeys.elementAt(0);      StringTokenizer st2 = new StringTokenizer(priKeyStr, delim);      while (st2.hasMoreTokens())      {        String colName = st2.nextToken();        if (!colNames.contains(colName))        {          return colName;        }      }    }    // Check foreign key definition    for (int i = 0; i < forKeys.size(); i++)    {      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st3 = new StringTokenizer(forKeyStr, delim);      while (st3.hasMoreTokens())      {        String colName = st3.nextToken();        if (colName.contains("references"))  // references 라는게 있으면, syntax 에러를 뱉어내기 위함인가?        {          break;        }        else if (!colNames.contains(colName))        {          return colName;        }      }    }    return null;  }}// Get referenced table names from this table and check whether those referenced tables are really existboolean CheckReferenceTableExistence(String tblName) :{}{  {    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    Vector<String> tblNames = myDB.getDB("@table name");    String refTblName = "";    for (int i = 0; i < forKeys.size(); i++)    {      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyStr, delim);      while (st.hasMoreTokens())      {        refTblName = st.nextToken();        if (refTblName.contains("references"))  // WHY THIS?        {          refTblName = refTblName.substring(12);          break;        }      }      if (!tblNames.contains(refTblName))      {        return true;      }    }    return false;  }}// Get referenced columns from this table and check whether these columns are not primary key of referenced tableboolean CheckReferenceNonPrimaryKey(String tblName) :{}{  {    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    String refTblName = "";    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyStr, delim);      Vector<String> refCols = new Vector<String>();      Vector<String> refPriKeyCols = new Vector<String>();      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }      }      Vector<String> refPriKeys = myDB.getDB(refTblName + " @primary key");      if (refPriKeys.size() > 0)      {        // Get primary key of referenced table        String refPriKeyStr = refPriKeys.elementAt(0);        StringTokenizer st2 = new StringTokenizer(refPriKeyStr, delim);        while (st2.hasMoreTokens())        {          String refPriKeyColName = st2.nextToken();          refPriKeyCols.addElement(refPriKeyColName);        }      }      // Check whether all of referenced columns are primary key      for (int j = 0; j < refCols.size(); j++)      {        if (!refPriKeyCols.contains(refCols.elementAt(j)))        {          return true;        }      }    }    return false;  }}// Get referenced columns from this table and check whether these columns are really exist in referenced tableboolean CheckReferenceColumnExistence(String tblName) :{}{  {    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    String refTblName = "";    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyStr, delim);      Vector<String> refCols = new Vector<String>();      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }      }      String refRealColDefStr = myDB.getDB(refTblName + " @column definition").elementAt(0);      Vector<String> refRealColNames = new Vector<String>();      StringTokenizer st2 = new StringTokenizer(refRealColDefStr, delim);      // Get columns of referenced table      while (st2.hasMoreTokens())      {        String colName = st2.nextToken();        String colType = st2.nextToken();        refRealColNames.addElement(colName);      }      // Check whether all of referenced columns exist in referenced table      for (int j = 0; j < refCols.size(); j++)      {        if (!refRealColNames.contains(refCols.elementAt(j)))        {          return true;        }      }    }    return false;  }}// Get type of referenced columns and referencing columns and check whether types of both columns are sameboolean CheckReferenceType(String tblName) :{}{  {    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    for (int i = 0; i < forKeys.size(); i++)    {      // Get referenced columns and referencing columns      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyStr, delim);      Vector<String> forCols = new Vector<String>();      Vector<String> refCols = new Vector<String>();      String refTblName = "";      boolean isRefCol = false;      while (st.hasMoreTokens())      {        String tmpstr = st.nextToken();        if (tmpstr.contains("references"))        {          refTblName = tmpstr.substring(12);          isRefCol = true;          continue;        }        else if (isRefCol)        {          String refColName = tmpstr;          refCols.addElement(refColName);        }        else        {          String forColName = tmpstr;          forCols.addElement(forColName);        }      }      // If number of referenced columns and referencing columns are different, type error      if (refCols.size() != forCols.size())      {        return true;      }      // Check type of these columns one by one      else      {        for (int j = 0; j < refCols.size(); j++)        {          String forColType = GetColumnType(tblName, forCols.elementAt(j));          String refColType = GetColumnType(refTblName, refCols.elementAt(j));          if (!forColType.equals(refColType))          {            return true;          }        }      }    }    return false;  }}// Get table names of DB and check whether this table existsboolean CheckNoSuchTable(String tblName) :{}{  {    Vector<String> tblNames = myDB.getDB("@table name");    return !tblNames.contains(tblName);  }}boolean CheckTupleIsReferenced(String refTblName, String tuple):{ boolean thisTupleIsReferenced = false ; }{    { Vector<String> tblNames = myDB.getDB("@table name");         for (int i = 0; i < tblNames.size(); i++)         {           Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");           for (int j = 0; j < forKeys.size(); j++)           { Vector<String> KeysToCompare  = new Vector<String>();             String forKeyStr = forKeys.elementAt(j);             StringTokenizer st = new StringTokenizer(forKeyStr, delim);             String tmpTbl = "";             while (st.hasMoreTokens())             {               String tmp = st.nextToken();               if (tmp.contains("references"))               {                 tmpTbl = tmp.substring(12);                 break;               } else { KeysToCompare.add(tmp); }             }             if (tmpTbl.equals(refTblName))             { Vector<String> tuples_possibly_referencing = myDB.getDB(tblNames.elementAt(i)+ " @tuple");               for( String suspect_tuple_referencing : tuples_possibly_referencing){                  thisTupleIsReferenced = true;                  for(int k = 0 ; k < KeysToCompare.size() ; k++)                  {                     String value = GetColumnValue(suspect_tuple_referencing, KeysToCompare.elementAt(k));                     String value_input = GetColumnValue(tuple, KeysToCompare.elementAt(k));                     if(!value.equals(value_input)){ thisTupleIsReferenced= false; break; }                  }                  if( thisTupleIsReferenced){ return true; }               }             }           }         }         return false;       }}// Get referenced table names of DB and check whether this table is referenced by other tableboolean CheckDropReferencedTable(String refTblName) :{}{  {    Vector<String> tblNames = myDB.getDB("@table name");    for (int i = 0; i < tblNames.size(); i++)    {      Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");      for (int j = 0; j < forKeys.size(); j++)      {        String forKeyStr = forKeys.elementAt(j);        StringTokenizer st = new StringTokenizer(forKeyStr, delim);        String tmpTbl = "";        while (st.hasMoreTokens())        {          String tmp = st.nextToken();          if (tmp.contains("references"))          {            tmpTbl = tmp.substring(12);            break;          }        }        if (tmpTbl.equals(refTblName))        {          return true;        }      }    }    return false;  }}// Check whether there is no tableboolean CheckShowTablesNoTable() :{}{  {    Vector<String> tblNames = myDB.getDB("@table name");    return (tblNames.size() == 0);  }}// Error Functionsvoid SelectColumnResolveError(String colName):{}{  {    System.out.println("Selection has failed: fail to resolve '"+colName+"'");    handleDBError(parser);  }}void SelectTableExistenceError(String tblName):{}{  {    System.out.println("Selection has failed: '"+tblName+"' does not exist");    handleDBError(parser);  }}void WhereIncomparableError():{}{  {    System.out.println("Where clause try to compare incomparable values");    handleDBError(parser);  }}void WhereTableNotSpecifiedError():{}{  {    System.out.println("Where clause try to reference tables which are not specified");    handleDBError(parser);  }}void WhereColumnNotExistError() :{}{  {    System.out.println("Where clause try to reference non existing column");    handleDBError(parser);  }}void WhereAmbiguousReferenceError() :{}{  {    System.out.println("Where clause contains ambiguous reference");    handleDBError(parser);  }}void NotUniqueAliasrError(String alias) :{}{  {    System.out.println("Not unique table/alias: '"+alias+"'");    handleDBError(parser);  }}void InsertReferentialIntegrityError():{}{    {    System.out.println("Insertion has failed: Referential integrity violation");    handleDBError(parser);    }}void InsertDuplicatePrimaryKeyError():{}{    {        System.out.println("Insertion has failed: Primary key duplication");        handleDBError(parser);    }}void InsertColumnNonNullableError(String colName) :{}{  {    System.out.println("Insertion has failed: '"+colName+"' is not nullable");    handleDBError(parser);  }}void InsertTypeMismatchError() :{}{  {    System.out.println("Insertion has failed:Insertion has failed: Types are not matched");    handleDBError(parser);  }}void InsertColumnExistenceError(String colName) :{}{  {    System.out.println( "Insertion has failed: '"+colName+"' does not exist");    handleDBError(parser);  }}void DuplicateColumnDefError(String tblName) :{}{  {    System.out.println("Create table has failed: column definition is duplicated");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void TableExistenceError() :{}{  {    System.out.println("Create table has failed: table with the same name already exist");    handleDBError(parser);  }}void CharLengthError() :{}{  {    System.out.println("Char length should be > 0");    handleDBError(parser);  }}void DuplicatePrimaryKeyDefError(String tblName) :{}{  {    System.out.println("Create table has failed: primary key definition is duplicated");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void NonExistingColumnDefError(String tblName, String colName) :{}{  {    System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceTableExistenceError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non existing table");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceNonPrimaryKeyError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non primary key column");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceColumnExistenceError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references non existing column");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void ReferenceTypeError(String tblName) :{}{  {    System.out.println("Create table has failed: foreign key references wrong type");    myDB.deleteTable(tblName);    handleDBError(parser);  }}void NoSuchTable() :{}{  {    System.out.println("No such table");    handleDBError(parser);  }}void DropReferencedTableError(String tblName) :{}{  {    System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");    handleDBError(parser);  }}void ShowTablesNoTable() :{}{  {    System.out.println("There is no table");    handleDBError(parser);  }}// utility functionsint DeleteTuples( String tblName , HashSet<HashMap<String,String>> result) :{  int fail_count = 0;   int count = 0 ;}{    {     String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);     Vector <String> colDefVector_with_tblName = new Vector<String>();     Vector <String> colDefVector = new Vector<String>();     Vector<String> tuples = myDB.getDB(tblName+ " @tuple");     StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);      // Get columns of referenced table     while (st2.hasMoreTokens())          {            String colName = st2.nextToken();            String colType = st2.nextToken();            colDefVector_with_tblName.addElement(tblName+"."+colName);            colDefVector.addElement(colName);          }    for(HashMap<String,String> result_tuple : result ){        for( int i = 0 ; i < tuples.size() ; i++ ){            boolean deleteThis = true;            for( int j = 0 ; j < colDefVector.size() ; j ++ ){                 String value = GetColumnValue(tuples.elementAt(i), colDefVector.elementAt(j));                 String value_result = result_tuple.get(colDefVector_with_tblName.elementAt(j));                if(!value.equals(value_result)){                    deleteThis = false;                }            }            if(deleteThis){            // CHECK WHETHER THIS IS allowedto be delted with the referencing constraints.            if ( CheckTupleIsReferenced(tblName, tuples.elementAt(i)) )            { fail_count++; }            else            {   count++; myDB.deleteTupleDB(tblName+ " @tuple",tuples.elementAt(i));            }          }        }        if(fail_count > 0){         System.out.println( fail_count+ " row(s) are not deleted due to referential integrity");        }    }    return count;    }}void CheckAndModifyAliasVector( Vector<String> alias_vector):{ String colName = "" ; String[] columnInfo; String tblName; }{    {      if(alias_vector.size() == 0){ // then select * must be called.        alias_vector.addAll(tblcol_table.keySet());          for( int i = 0 ; i < alias_vector.size() ; i ++ )          { String alias = alias_vector.elementAt(i);            selectedColumn_table.put(alias,alias);           }      }       for( int i = 0 ; i < alias_vector.size() ; i ++ ){        String colName_str = selectedColumn_table.get(alias_vector.elementAt(i));        columnInfo = colName_str.split("\\.");        if(columnInfo.length == 2){ // tblName.colName과 col Name을 구분한다.           tblName = columnInfo[0];           colName  = columnInfo[1];           if( CheckNoSuchTable(tblName) // tblName이 from 절에 나오는 alias인 경우에도, 올바른 경우이므로 이 경우에 에러를 던지지 않기 위해서 이 부분이 필요            && !alias_table.containsKey(tblName)){SelectTableExistenceError(tblName); }           Set<String> keySet = tblcol_table.keySet(); // tuple의 key 값 중에 하나인가?           if(!keySet.contains(colName_str)){ SelectColumnResolveError(colName);}        } else {           String operand = colName_str;           if(!tblname_table.containsKey(operand)){ SelectColumnResolveError(colName_str);}           else if (tblname_table.get(operand).equals("@duplication"))           { SelectColumnResolveError(colName_str); }             selectedColumn_table.put(alias_vector.elementAt(i),  tblname_table.get(operand)+"."+operand);        }      }    }}HashSet<HashMap<String,String>> FilterTuples(String operand1, String operand2, String operator):{HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>(); String value1 ="" ; String dataType1 =""; String value2 ="" ; String dataType2 =""; Integer value1_int = 0 ; Integer value2_int = 0; boolean value1IsAttribute= true; boolean value2IsAttribute= true ; int comparation = 0 ;}{    {      Set<String> keySet = tblcol_table.keySet();      if(!keySet.contains(operand1))      { value1IsAttribute = false;        value1 = operand1.substring(1);        dataType1 = operand1.substring(0,1);      } else { dataType1 = tblcol_table.get(operand1).substring(0,1);}      if(!keySet.contains(operand2))      { value2IsAttribute = false;        value2 = operand2.substring(1);        dataType2 = operand2.substring(0,1);      } else { dataType2 = tblcol_table.get(operand2).substring(0,1);}     if(!dataType1.equals(dataType2)){ WhereIncomparableError(); }     else {        for(HashMap<String,String> tuple : tuple_space){            if(value1IsAttribute){ value1 = tuple.get(operand1); }            if(value2IsAttribute){ value2 = tuple.get(operand2); }              if( dataType1.equals("i") ){                value1_int = Integer.parseInt(value1);                value2_int = Integer.parseInt(value2);                comparation = value1_int.compareTo(value2_int);               } else { comparation = value1.compareTo(value2); }            switch(operator){               case "<" : { if(comparation<0) result.add(tuple); break; }               case ">" : { if(comparation>0) result.add(tuple); break; }               case "=" :{ if(comparation == 0 )  result.add(tuple); break; }               case ">=" :{ if(comparation>=0) result.add(tuple); break; }               case "<=" :{ if(comparation <= 0 ) result.add(tuple); break; }               case "!=" :{ if(comparation!= 0) result.add(tuple); break; }            }         }       }     return result;    }}void ExtendTableHash(String alias):{}{       {  String tblName = alias_table.get(alias);          String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);          StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);          Vector <String> colDefVector = new Vector<String>();          while (st2.hasMoreTokens())                      {                        String colName = st2.nextToken();                        String colType = st2.nextToken();                        tblcol_table.put(alias+"."+colName, colType);                        if(tblname_table.containsKey(colName)){                                 tblname_table.put(colName,"@duplication");                        } else { tblname_table.put(colName,alias); }                      }       }}void ExtendTupleSpace(String alias): // cartesian proudct를 해준다.// 또한 colName()만 들어왔을 때, 테이블 네임을 연장 시켜줄 수 있게 해주는 hash talbe인// tblname_table을 채운다.{}{    {    if(tuple_space.size() == 0 ){      String tblName = alias_table.get(alias);      String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);      Vector <String> colDefVector_alias = new Vector<String>();      StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);      Vector <String> colDefVector = new Vector<String>();            while (st2.hasMoreTokens())            {              String colName = st2.nextToken();              String colType = st2.nextToken();              colDefVector_alias.addElement(alias+"."+colName);              colDefVector.addElement(colName);            }      Vector<String> tuples = myDB.getDB(tblName+ " @tuple");       for(int i = 0 ; i < tuples.size() ; i++){            HashMap<String,String> tuple = new HashMap<String,String>();             for(int j = 0 ; j <colDefVector.size() ; j++ ){                String colName =  colDefVector.elementAt(j);                String value = GetColumnValue(tuples.elementAt(i), colName);                tuple.put(colDefVector_alias.elementAt(j), value);             }           tuple_space.add(tuple);       }    }    else {            HashSet<HashMap<String,String>> newTupleSet =new HashSet<HashMap<String,String>> ();            for(HashMap<String,String> tuple : tuple_space){                      String tblName = alias_table.get(alias);                      String ColDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);                      Vector <String> colDefVector_alias = new Vector<String>();                      Vector <String> colDefVector = new Vector<String>();                      StringTokenizer st2 = new StringTokenizer(ColDefStr, delim);                            // Get columns of referenced table                            while (st2.hasMoreTokens())                            {                              String colName = st2.nextToken();                              String colType = st2.nextToken();                              colDefVector_alias.addElement(alias+"."+colName);                              colDefVector.addElement(colName);                            }                      Vector<String> tuples = myDB.getDB(tblName+ " @tuple");                       for(int i = 0 ; i < tuples.size() ; i++){                             HashMap<String,String> tuple_extended = (HashMap<String,String> ) tuple.clone();                             for(int j = 0 ; j <colDefVector.size() ; j++ ){                                String colName =  colDefVector.elementAt(j);                                String value = GetColumnValue(tuples.elementAt(i), colName);                                tuple_extended.put(colDefVector_alias.elementAt(j), value);                             }                                  newTupleSet.add(tuple_extended);                       }            }            tuple_space = newTupleSet;    }    }}String GetColumnValue(String tupleString, String colName):{}{    {      StringTokenizer st =  new StringTokenizer(tupleString, delim);         while (st.hasMoreTokens())                    {                      String col_name = st.nextToken();                      String col_val = st.nextToken();                      if(col_name.equals(colName)){                        return col_val;                      }                    }      return null;    }}void addNullExiplicitly(String tblName) :{}{    {            String colValStr = myDB.getDB(tblName + " @tmptuple").elementAt(0);            StringTokenizer st1 = new StringTokenizer(colValStr, delim);            Vector<String> tmp = new Vector<String>();              while (st1.hasMoreTokens())                        {                          String col_name = st1.nextToken();                          String col_value = st1.nextToken();                          tmp.addElement(col_name);                        }            String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);            StringTokenizer st = new StringTokenizer(colDef, delim);            while (st.hasMoreTokens())            {              String colName = st.nextToken();              String colType = st.nextToken();              if (!tmp.contains(colName))              {                 colValStr += "|"+colName+"|null";              }            }            myDB.deleteDB(tblName + " @tmptuple");            myDB.putDB(tblName+" @tmptuple", colValStr);    }}boolean IsColumnNullable(String tblName, String colName) :{}{  {    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDefStr, delim);    while (st.hasMoreTokens())    {      String _colName = st.nextToken();      String colType = st.nextToken();      if (colName.equals(_colName))      {        StringTokenizer st2 = new StringTokenizer(colType, "*");        st2.nextToken();        return !st2.hasMoreTokens();      }    }    return false; // never reached since the argument must be valid.  }}// Get type of columnString GetColumnType(String tblName, String colName) :{}{  {    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDefStr, delim);    while (st.hasMoreTokens())    {      String _colName = st.nextToken();      String colType = st.nextToken();      if (colName.equals(_colName))      {        StringTokenizer st2 = new StringTokenizer(colType, "*");        return st2.nextToken();      }    }    return null;  }}// Change columns of primary key to not nullvoid ChangeToNotNull(String tblName) :{}{  {    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");    if (priKeys.size() > 0)    {      // Get primary keys      Vector<String> priCols = new Vector<String>();      String priKeyStr = priKeys.elementAt(0);      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);      myDB.deleteDB(tblName + " @column definition");      StringTokenizer st = new StringTokenizer(priKeyStr, delim);      while (st.hasMoreTokens())      {        priCols.addElement(st.nextToken());      }      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);      String newColDef = "";      // Change type of primary keys to not null by deleting and re-inserting primary key data      while (st2.hasMoreTokens())      {        String colName = st2.nextToken();        String colType = st2.nextToken();        StringTokenizer st3 = new StringTokenizer(colType, "*");        String realColType = st3.nextToken();        if (priCols.contains(colName) && !st3.hasMoreTokens())        {          newColDef += "|" + colName + "|" + realColType + "*not null";        }        else        {          newColDef += "|" + colName + "|" + colType;        }      }      myDB.putDB(tblName + " @column definition", newColDef.substring(1));    }  }}// Perform drop table queryvoid DropTable(String tblName) :{}{  {    myDB.deleteTable(tblName);    myDB.deleteDB("@table name");    tblNameList.remove(tblName);    for (int i = 0; i < tblNameList.size(); i++)    {      myDB.putDB("@table name", tblNameList.elementAt(i));    }  }}void ShowTuples(  Vector<String>alias_vector,  HashSet<HashMap<String,String>> result):{ String line = ""; String lineformat = ""; String format = ""; String field_name_format = "";}{    {        for(int j = 0 ; j <  26 ; j ++){            line += "-";        } // generate lines.        for( int i = 0 ; i < alias_vector.size() ; i++ ){                    lineformat += "%-26s+"  ;        } // generate line format        String[] lines = new String[alias_vector.size()]; // generate lines array.        for( int i = 0 ; i < alias_vector.size() ; i++ ){             field_name_format += "  %-22s  |"  ;        } // generate field_name format        for( int i = 0 ; i < alias_vector.size() ; i++ ){                    if((i % 2) == 0)                    { format += "  %22s  |"  ; }                    else                    {format += "  %-22s  |"  ;}                    lines[i] = line;        } // generate field format        String[] selectedColumnString = new String[alias_vector.size()];        selectedColumnString = alias_vector.toArray(selectedColumnString);        System.out.println(String.format(lineformat, (Object[])lines));        System.out.println(String.format(field_name_format, (Object[])selectedColumnString));        System.out.println(String.format(lineformat, (Object[])lines));        /* completion of Fomatting. now start showing datas from tuples */         for(HashMap<String,String> item : result){                Vector<String> tupleVector = new Vector<String>(alias_vector.size());                for(int k = 0 ; k < alias_vector.size() ; k ++ ){                    String realAttributeName = selectedColumn_table.get(alias_vector.elementAt(k));                    String value = item.get(realAttributeName);                    tupleVector.add(k,value);                }               String[] tupleResult = new String[tupleVector.size()];               tupleResult = tupleVector.toArray(tupleResult);               System.out.println(String.format(format, (Object[])tupleResult));               System.out.println(String.format(lineformat, (Object[])lines));         }    }}// Perform show tables queryvoid ShowTables() :{}{  {    Vector<String> tblNames = myDB.getDB("@table name");    System.out.println("-------------------------");    for (int i = 0; i < tblNames.size(); i++)    {      System.out.println(tblNames.elementAt(i));    }    System.out.println("-------------------------");  }}// Check whether given column is primary key columnboolean IsPrimaryKey(String tblName, String colName) :{}{  {    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");    if (priKeys.size() > 0)    {      String priKeyStr = priKeys.elementAt(0);      StringTokenizer st = new StringTokenizer(priKeyStr, delim);      while (st.hasMoreTokens())      {        String tmp = st.nextToken();        if (tmp.equals(colName))        {          return true;        }      }    }    return false;  }}// Check whether given column is foreign key columnboolean IsForeignKey(String tblName, String colName) :{}{  {    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");    for (int i = 0; i < forKeys.size(); i++)    {      String forKeyStr = forKeys.elementAt(i);      StringTokenizer st = new StringTokenizer(forKeyStr, delim);      while (st.hasMoreTokens())      {        String tmp = st.nextToken();        if (tmp.contains("references"))        {          break;        }        else if (tmp.equals(colName))        {          return true;        }      }    }    return false;  }}// Perform desc queryvoid Describe(String tblName) :{}{  {    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);    StringTokenizer st = new StringTokenizer(colDef, delim);    System.out.println("------------------------------------------------------------");    System.out.println("table_name [" + tblName + "]");    System.out.printf("%-25s%-15s%-10s%-10s\n", "column_name", "type", "null", "key");    while (st.hasMoreTokens())    {      String colName = st.nextToken();      String colType = st.nextToken();      boolean isNotNull = false;      boolean isPriKey = IsPrimaryKey(tblName, colName);      boolean isForKey = IsForeignKey(tblName, colName);      StringTokenizer st2 = new StringTokenizer(colType, "*");      String realColType = st2.nextToken();      if (st2.hasMoreTokens())      {        isNotNull = true;      }      System.out.printf("%-25s%-15s", colName, realColType);      if (isNotNull)      {        System.out.printf("%-10s", "N");      }      else      {        System.out.printf("%-10s", "Y");      }      if (isPriKey && isForKey)      {        System.out.printf("%-10s\n", "PRI/FOR");      }      else if (isPriKey)      {        System.out.printf("%-10s\n", "PRI");      }      else if (isForKey)      {        System.out.printf("%-10s\n", "FOR");      }      else      {        System.out.print("\n");      }    }    System.out.println("------------------------------------------------------------");  }}// Success Functionsvoid CreateTableSuccess() :{}{  {    System.out.println("'" + createTblName + "' table is created");  }}void DropSuccess() :{}{  {    System.out.println("'" + dropTblName + "' table is dropped");  }}// Parsing Functionsvoid Command() :{}{  QueryList()}void QueryList() :{  int i;}{  (    i = Query()    (      (        < SEMICOLON >        {          Success(i);        }      )    |      (        (          ";\r"        | ";\n"        )        {          Success(i);          System.out.print("DB_2014-16962 > ");        }      )    )  )+}int Query() :{  int i;}{  (    i = CreateTableQuery()  | i = DropTableQuery()  | i = ShowTablesQuery()  | i = DescQuery()  | i = SelectQuery()  | i = InsertQuery()  | i = DeleteQuery()  | i = ExitQuery()  )  {    return i;  }}int ExitQuery() :{}{  < EXIT >  { System.out.println("tblname_table: "+tblname_table.toString());    return - 1;  }}int CreateTableQuery() :{  String tblName;  String colName;}{  < CREATE_TABLE > tblName = TableName()  {    if (CheckTableExistence(tblName))    {      TableExistenceError();    }  }  TableElementList(tblName)  {    myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));    tmpColDef = "";    tmpPriKey = "";    tmpForKey = "";    if (CheckDuplicateColumnDef(tblName))    {      DuplicateColumnDefError(tblName);    }    else if (CheckDuplicatePrimaryKeyDef(tblName))    {      DuplicatePrimaryKeyDefError(tblName);    }    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)    {      NonExistingColumnDefError(tblName, colName);    }    else if (CheckReferenceTableExistence(tblName))    {      ReferenceTableExistenceError(tblName);    }    else if (CheckReferenceColumnExistence(tblName))    {      ReferenceColumnExistenceError(tblName);    }    else if (CheckReferenceNonPrimaryKey(tblName))    {      ReferenceNonPrimaryKeyError(tblName);    }    else if (CheckReferenceType(tblName))    {      ReferenceTypeError(tblName);    }    ChangeToNotNull(tblName);    createTblName = tblName;    myDB.putDB("@table name", tblName);    tblNameList.addElement(tblName);    return 0;  }}void TableElementList(String tblName) :{}{  < LEFT_PAREN > TableElement(tblName)  (    < COMMA > TableElement(tblName)  )*  < RIGHT_PAREN >}void TableElement(String tblName) :{}{  ColumnDefinition()| TableConstraintDefinition(tblName)}void ColumnDefinition() :{  String colName = "";  String dataType = "";  String notNull = "";}{  (    LOOKAHEAD(ColumnName() DataType() < NOT_NULL >)    (      colName = ColumnName() dataType = DataType() < NOT_NULL >      {        notNull = "*not null";      }    )  |    (      colName = ColumnName() dataType = DataType()    )  )  (  {    tmpColDef += delim + colName + delim + dataType + notNull;  }  )}void TableConstraintDefinition(String tblName) :{}{  PrimaryKeyConstraint(tblName)| ReferentialKeyConstraint(tblName)}void PrimaryKeyConstraint(String tblName) :{}{  < PRIMARY_KEY > ColumnNameList(true)  {    myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));  }}void ReferentialKeyConstraint(String tblName) :{  String referedTblName;}{  < FOREIGN_KEY > ColumnNameList(false) < REFERENCES > referedTblName = TableName()  {    tmpForKey += delim + "@references&" + referedTblName;  }  ColumnNameList(false)  {    myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));    tmpForKey = "";  }}void ColumnNameList_insertion() :{  String colName;}{  < LEFT_PAREN > colName = ColumnName()  {    {      tmpCols += delim + colName;    }  }  (    < COMMA > colName = ColumnName()    {      {        tmpCols += delim + colName;      }    }  )*  < RIGHT_PAREN >}void ColumnNameList(boolean isPrimaryKey) :{  String colName;}{  < LEFT_PAREN > colName = ColumnName()  {    if (isPrimaryKey)    {      tmpPriKey += delim + colName;    }    else    {      tmpForKey += delim + colName;    }  }  (    < COMMA > colName = ColumnName()    {      if (isPrimaryKey)      {        tmpPriKey += delim + colName;      }      else      {        tmpForKey += delim + colName;      }    }  )*  < RIGHT_PAREN >}String DataType() :{  Token size;}{  < INT >  {    return "int";  }|  (    < CHAR > < LEFT_PAREN >    (      size = < INT_VALUE >    | size = < DIGIT >    )    < RIGHT_PAREN >    {      if (Integer.parseInt(size.image) <= 0) CharLengthError();      return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";    }  )| < DATE >  {    return "date";  }}String TableName() :{  Token t;}{  (    t = < LEGAL_IDENTIFIER >    {      if (IsKeyword(t.image))      {        throw new ParseException();      }    }  | t = < ALPHABET >  )  {    return t.image.toLowerCase();  }}String ColumnName() :{  Token t;}{  (    t = < LEGAL_IDENTIFIER >    {      if (IsKeyword(t.image))      {        throw new ParseException();      }    }  | t = < ALPHABET >  )  {    return t.image.toLowerCase();  }}int DropTableQuery() :{  String tblName;}{  < DROP_TABLE > tblName = TableName()  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }    else if (CheckDropReferencedTable(tblName))    {      DropReferencedTableError(tblName);    }    else    {      dropTblName = tblName;      DropTable(tblName);    }    return 1;  }}int ShowTablesQuery() :{}{  < SHOW_TABLES >  {    if (CheckShowTablesNoTable())    {      ShowTablesNoTable();    }    else    {      ShowTables();    }    return 2;  }}int DescQuery() :{  String tblName;}{  < DESC > tblName = TableName()  {    if (CheckNoSuchTable(tblName))    {      NoSuchTable();    }    else    {      Describe(tblName);    }    return 3;  }}int SelectQuery() :{ Vector<String> alias_vector = new Vector<String>();  HashSet<HashMap<String,String>> result ;  tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>}{  < SELECT > SelectList(alias_vector) result = TableExpression()  {    CheckAndModifyAliasVector(alias_vector);    if(result.size() != 0)    { ShowTuples(alias_vector, result); }    else { System.out.println("Empty set");}    return 4;  }}void SelectList(Vector<String> alias_vector) :{ selectedColumn_table = new Hashtable<String,String>(); }{  "*"{} // 이는 위에서 처리할 것임|  (    SelectedColumn(alias_vector)    (      < COMMA > SelectedColumn(alias_vector)    )*  )}void SelectedColumn(Vector<String> alias_vector) :{String alias = ""; }{  LOOKAHEAD(SelectedColumnAux1())  alias = SelectedColumnAux1() { alias_vector.add(alias);}| LOOKAHEAD(SelectedColumnAux2())  alias =  SelectedColumnAux2(){alias_vector.add(alias);}| LOOKAHEAD(SelectedColumnAux3())  alias = SelectedColumnAux3(){alias_vector.add(alias);}| alias = ColumnName()  { selectedColumn_table.put(alias,alias);    alias_vector.add(alias);  }}String SelectedColumnAux1() :{ String tblName = "";   String colName = "" ; String alias ="";}{   tblName = TableName() < PERIOD > colName = ColumnName()   < AS > alias =  ColumnName() {      selectedColumn_table.put(alias,tblName+"."+colName);         return alias;   }}String SelectedColumnAux2() :{ String tblName = "";  String colName = "" ; String alias ="";}{  tblName = TableName() < PERIOD > colName = ColumnName()  { alias = tblName+"."+colName;    selectedColumn_table.put(alias,alias);    return alias;  }}String SelectedColumnAux3() :{ String colName = "" ; String alias =""; }{  colName = ColumnName() < AS > alias = ColumnName()  {selectedColumn_table.put(alias,colName); return alias ; }}HashSet<HashMap<String,String>> TableExpression() :{ HashSet<HashMap<String,String>> result = new  HashSet<HashMap<String,String>>();}{  LOOKAHEAD(FromClause() WhereClause())  FromClause() result = WhereClause(){ return result;}| FromClause() { return tuple_space; }}void FromClause() :{ alias_table = new Hashtable<String,String>();  tuple_space =new HashSet<HashMap<String,String>> ();  tblname_table = new Hashtable<String,String>(); }{  < FROM > TableReferenceList() {  }}void TableReferenceList() :{String alias=""; }{  alias = ReferedTable(){ ExtendTupleSpace(alias);  ExtendTableHash(alias); }  (    < COMMA > alias = ReferedTable(){ ExtendTupleSpace(alias); ExtendTableHash(alias);}  )*}String ReferedTable() :{ String alias = "";  String tblName = ""; }{  LOOKAHEAD(TableName() < AS > TableName())  tblName = TableName() < AS > alias = TableName()   { if (CheckNoSuchTable(tblName))        {          NoSuchTable();        }    if(alias_table.containsKey(alias)){        NotUniqueAliasrError(alias );    }    alias_table.put(alias,tblName); return alias;}| tblName = TableName()   {    if (CheckNoSuchTable(tblName))       {         NoSuchTable();       }   alias_table.put(tblName,tblName);   return tblName;  } // alias가 없는 경우에는, 통일성을 위해 자신의 이름을 alias로 설정해준다}HashSet<HashMap<String,String>> WhereClause() :{ HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();}{  < WHERE > result = BooleanValueExpression()  {  return result;  }}HashSet<HashMap<String,String>>  BooleanValueExpression() :{    HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();     HashSet<HashMap<String,String>> tmp = new HashSet<HashMap<String,String>>();}{  result = BooleanTerm() {}// BooleanTerm의 반환형은 tuple_space와 같아야한다.  (    < OR > tmp = BooleanTerm(){ result.addAll(tmp); }  )*{return result;}}HashSet<HashMap<String,String>> BooleanTerm() :{  HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();   HashSet<HashMap<String,String>> tmp = new HashSet<HashMap<String,String>>(); }{  result = BooleanFactor() { /* return result ; */}  (    < AND > tmp = BooleanFactor()    {  result.retainAll(tmp); /* return result ; */    }// tuple_space 에서 빼다가 사용!  )*  { return result; }}HashSet<HashMap<String,String>> BooleanFactor() :{HashSet<HashMap<String,String>> temp = new HashSet<HashMap<String,String>>();HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();}{ result =  BooleanTest(){ return result; }| < NOT > temp = BooleanTest(){ result.addAll(tuple_space); result.removeAll(temp);return result; }}HashSet<HashMap<String,String>> BooleanTest() :{HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();}{  result = Predicate(){ return result;}| result = ParentehsizedBooleanExpression() {return result;}}HashSet<HashMap<String,String>>  ParentehsizedBooleanExpression() :{HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();}{  < LEFT_PAREN > result = BooleanValueExpression()  < RIGHT_PAREN > {return result;}}HashSet<HashMap<String,String>> Predicate() : // return type must be the same as tuple_space{HashSet<HashMap<String,String>> result = new HashSet<HashMap<String,String>>();}{  LOOKAHEAD(ComparisonPredicate())  result = ComparisonPredicate() { return result ;}| result = NullPredicate(){ return result; }}HashSet<HashMap<String,String>> ComparisonPredicate() : //TODO return type must be HashSet<HashMap<String,String>>{ String operand1 = "";  String operand2 = "";  Token operator;  String operator_str ="";  HashSet<HashMap<String,String>> result =  new HashSet<HashMap<String,String>>();}{  operand1 = CompOperand()  operator = < COMP_OP >{ operator_str = operator.image;}  operand2 = CompOperand(){      result = FilterTuples(operand1, operand2, operator_str);      return result;  }}String CompOperand() :{ String operand = ""; }{  LOOKAHEAD(CompOperandAux())  operand = CompOperandAux()  {     Set<String> keySet = tblcol_table.keySet();     if(!keySet.contains(operand)){ WhereColumnNotExistError(); }     return operand;  }| operand = ColumnName()  { if(! tblname_table.containsKey(operand)) { WhereColumnNotExistError(); }    else if (tblname_table.get(operand).equals("@duplication")){ WhereAmbiguousReferenceError(); }    return tblname_table.get(operand)+"."+operand;  }| operand = ComparableValue_inWhereClause()   { return operand; }}String CompOperandAux() :{ String result = "";  String TblName = "";  String ColName = "";} {  TblName = TableName() < PERIOD > ColName = ColumnName() {   if  (!alias_table.containsKey(TblName))        {         WhereTableNotSpecifiedError(); // talbe이 alias table 에 존재하는 지 본다 (alias가 없는 경우 자신의 이름으로 aliastable에 들어가 있다)        }   result = TblName+"."+ColName;   return result;  }}String ComparableValue_inWhereClause() :{ Token t; }{  t = < DATE_VALUE >{ return "d"+t.image.toLowerCase(); }| t = < INT_VALUE >{ return "i"+t.image.toLowerCase(); }| t = < DIGIT >{ return "i"+t.image.toLowerCase(); }| t = < CHAR_STRING >{ return "c"+t.image.toLowerCase(); }}String ComparableValue() :{ Token t; }{  t = < DATE_VALUE >{ return t.image.toLowerCase(); }| t = < INT_VALUE >{ return t.image.toLowerCase(); }| t = < DIGIT >{ return t.image.toLowerCase(); }| t = < CHAR_STRING >{ return t.image.toLowerCase(); }}HashSet<HashMap<String,String>> NullPredicate() :{HashSet<HashMap<String,String>> tuple_set_result = new HashSet<HashMap<String,String>> ();String operand = ""; String condition ="";}{  LOOKAHEAD(NullPredicateAux())  operand = NullPredicateAux()  {                                   Set<String> keySet = tblcol_table.keySet();                                   if(!keySet.contains(operand)){ WhereColumnNotExistError(); }                                }  tuple_set_result = NullOperation(operand)  { return tuple_set_result;  }| operand = ColumnName()   {    if(! tblname_table.containsKey(operand)) { WhereColumnNotExistError(); }                                else if (tblname_table.get(operand).equals("@duplication")){ WhereAmbiguousReferenceError(); }                                operand = tblname_table.get(operand)+"."+operand;                           }  tuple_set_result =  NullOperation(operand)  { return tuple_set_result; }}String NullPredicateAux() :{  String result = "";   String tblName = "";   String ColName = ""; }{     tblName = TableName() < PERIOD > ColName = ColumnName() {     if (CheckNoSuchTable(tblName))         {           NoSuchTable();         }                          // COME BACK     result = tblName+"."+ColName; //윗단에서, 만약 이 result를 key로 갖는 value가 없는 경우엔 존재하지 않는 column임을 나타내는 에러를 띄운다     return result;    }}HashSet<HashMap<String,String>> NullOperation(String operand) :{ HashSet<HashMap<String,String>> result_tuple_set = new HashSet<HashMap<String,String>> (); }{  < IS_NULL >  {     for(HashMap<String,String> item : tuple_space){                if( item.get(operand).equals("null")){                    result_tuple_set.add(item);                }     }     return result_tuple_set;  }| < IS_NOT_NULL >  {  for(HashMap<String,String> item : tuple_space){                     if(!item.get(operand).equals("null")){                         result_tuple_set.add(item);                     }          }          return result_tuple_set;   }}int InsertQuery() :{ createTblName = "";  String tblName;  String colName;  tmpCols = "";  tmpVals = "";}{  < INSERT_INTO > tblName = TableName() InsertColumnsAndSource()  {    myDB.deleteDB(tblName+" @tmptuple"); // 에러가 났을 경우 아직도 남아있을 수 있기 때문에..    if (!CheckTableExistence(tblName))        {          NoSuchTable();        }    if ( (colName = CheckInsertColumnExistence(tblName)) !=     null ) {            InsertColumnExistenceError(colName);        }    if ( (CheckInsertTypeMismatch(tblName))){            InsertTypeMismatchError();    }    if ( (colName = CheckInsertColumnNonNullable(tblName))!= null){            InsertColumnNonNullableError(colName);    }    if ( CheckInsertDuplicatePrimaryKeyError(tblName)){        InsertDuplicatePrimaryKeyError();    }    if ( !CheckInsertReferentialIntegrity(tblName)){        InsertReferentialIntegrityError();    }   myDB.putDB(tblName + " @tuple", myDB.getDB(tblName+" @tmptuple").elementAt(0));   return 5;  }}void InsertColumnsAndSource() :{}{  (    ColumnNameList_insertion()  )?  ValueList()}void ValueList() :{ String valName; }{   < VALUES > < LEFT_PAREN > valName = Value()  {    { //COMBAC      tmpVals += delim + valName;    }  }  (    < COMMA > valName = Value()    {      {        tmpVals += delim + valName;      }    }  )*  < RIGHT_PAREN >}String Value() :{ Token t;   String s = "";}{  t = < NULL >  {      return t.image.toLowerCase();  }| s = ComparableValue()  {      return s.toLowerCase();  }}int DeleteQuery() :{   String tblName;    Vector<String> alias_vector = new Vector<String>();    HashSet<HashMap<String,String>> result ;    tblcol_table = new Hashtable<String,String>(); // <K,V> = <alias.colName, type>    alias_table = new Hashtable<String,String>();    tuple_space =new HashSet<HashMap<String,String>> ();    tblname_table = new Hashtable<String,String>();    tblcol_table = new Hashtable<String,String>(); }{  < DELETE_FROM > tblName = TableName()  {    alias_table.put(tblName,tblName);    ExtendTupleSpace(tblName);    ExtendTableHash(tblName);    result = tuple_space;   }  (    result =WhereClause()  )?  {    if (CheckNoSuchTable(tblName))            {              NoSuchTable();            }    int count = DeleteTuples(tblName,result);    System.out.println(count+" rows are deleted");    return 6;  }}boolean IsKeyword(String s) :{}{  {    return keywordSet.contains(s.toLowerCase());  }}void Success(int i) :{}{  {    switch (i)    {      case 0 :      CreateTableSuccess();      break;      case 1 :      DropSuccess();      break;      case 4 :      break;      case 5 : System.out.println("The row is inserted.");      break;      case 6 :      break;      case - 1 : myDB.closeDB();      System.exit(0);      break;    }  }}void Start() :{  Token t;}{  {    System.out.print("DB_2014-16962 > ");  }  (    Command()  )*  {    System.out.println("Syntax error");    parser = new SimpleDBMS(System.in);    handleSyntaxError(parser);  }}SKIP :{  < _SPACE : < SPACE >>| "\t"| "\n"| "\r"}TOKEN : // Elementary{  < SEMICOLON : ";" >| < UNDERSCORE : "_" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < PERIOD : "." >| < COMP_OP :    "<"  | ">"  | "="  | ">="  | "<="  | "!=" >| < DIGIT : [ "0"-"9" ] >| < SIGN :    (      "+"    | "-"    ) >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS :    "`"  | "~"  | "!"  | "@"  | "#"  | "$"  | "%"  | "^"  | "&"  | "*"  | "("  | ")"  | "_"  | "-"  | "+"  | "="  | "|"  | "["  | "]"  | ":"  | "<"  | ","  | ">"  | "."  | "?"  | "/" >| < ALPHABET : [ "A"-"Z", "a"-"z" ] >| < SPACE : " " >| < SPACES :    " "  | "\n"  | "\r"  | "\t" >}TOKEN : // Keywords{  < EXIT : "exit" >| < CREATE_TABLE : "create table">| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < DROP_TABLE : "drop table">| < SHOW_TABLES : "show tables" >| < DESC : "desc">| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < AND : "and" >| < OR : "or" >| < NOT : "not" >| < IS_NULL : "is null" >| < IS_NOT_NULL : "is not null" >| < INSERT_INTO : "insert into" >| < VALUES : "values" >| < NULL : "null" >| < DELETE_FROM : "delete from" >}TOKEN : // Comprised{  < LEGAL_IDENTIFIER :    < ALPHABET >    (      < ALPHABET >    | < UNDERSCORE >    )* >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < DATE_VALUE : < DIGIT > < DIGIT > < DIGIT > < DIGIT > "-" < DIGIT > < DIGIT > "-" < DIGIT > < DIGIT >>| < CHAR_STRING :    < QUOTE >    (      < DIGIT >    | < ALPHABET >    | < NON_QUOTE_SPECIAL_CHARACTERS >    | < SPACE >    )*    < QUOTE >>}